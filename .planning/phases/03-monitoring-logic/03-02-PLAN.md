---
phase: 03-monitoring-logic
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/analysis/decision_engine.py
  - tests/test_decision_engine.py
autonomous: true

must_haves:
  truths:
    - "Every program receives an advocacy goal classification or an explicit 'no match' with reason"
    - "LOGIC-05 Urgent Stabilization overrides all other rules when THREATENS edge within 30 days exists"
    - "LOGIC-01 Restore/Replace triggers for TERMINATED programs with active statutory authority"
    - "LOGIC-02 Protect Base triggers for discretionary-funded programs facing ELIMINATE/REDUCE signals"
    - "LOGIC-03 Direct Access Parity triggers for state pass-through programs with high administrative burden"
    - "LOGIC-04 Expand and Strengthen triggers for STABLE/SECURE programs with direct/set-aside access"
    - "Priority order is enforced: LOGIC-05 > 01 > 02 > 03 > 04"
  artifacts:
    - path: "src/analysis/decision_engine.py"
      provides: "DecisionEngine with 5 advocacy goal rules"
      exports: ["DecisionEngine", "ADVOCACY_GOALS"]
      contains: "classify_all"
    - path: "tests/test_decision_engine.py"
      provides: "Test coverage for all 5 decision rules plus edge cases"
      contains: "test_"
  key_links:
    - from: "src/analysis/decision_engine.py"
      to: "graph_data dict"
      via: "queries edges list for THREATENS, AUTHORIZED_BY, FUNDED_BY, BLOCKED_BY"
      pattern: "edge.*type.*THREATENS|AUTHORIZED_BY|FUNDED_BY|BLOCKED_BY"
    - from: "src/analysis/decision_engine.py"
      to: "program dict"
      via: "reads ci_status, funding fields from program inventory data"
      pattern: "ci_status|funding_type|access_type"
---

<objective>
Implement the 5-rule advocacy goal decision engine using TDD. Each program is classified into one of five advocacy goals (Urgent Stabilization, Restore/Replace, Protect Base, Direct Access Parity, Expand and Strengthen) based on its graph state, CI status, and monitor findings.

Purpose: The decision engine is the analytical core of Phase 3 -- it translates raw monitoring data and graph state into actionable advocacy classifications that Phase 4 reports will display.
Output: Tested `src/analysis/decision_engine.py` with full coverage of all 5 rules plus default/edge cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-monitoring-logic/03-RESEARCH.md

@src/analysis/relevance.py
@src/analysis/change_detector.py
@src/graph/schema.py
@src/graph/builder.py
@data/program_inventory.json
@data/graph_schema.json
</context>

<feature>
  <name>Advocacy Goal Decision Engine</name>
  <files>src/analysis/decision_engine.py, tests/test_decision_engine.py</files>
  <behavior>
    The DecisionEngine class accepts config dict and programs dict (keyed by program_id).
    classify_all(graph_data, alerts) returns {program_id: classification_dict} for every program.

    Classification dict shape:
    {
      "advocacy_goal": str | None,     # ADVOCACY_GOALS key or None
      "goal_label": str | None,        # Human-readable label
      "rule": str | None,              # "LOGIC-01" through "LOGIC-05" or None
      "confidence": str,               # "HIGH", "MEDIUM", "LOW"
      "reason": str,                   # Why this rule matched
      "secondary_rules": list[str],    # Other rules that also matched (for transparency)
    }

    ADVOCACY_GOALS constant:
    {
      "URGENT_STABILIZATION": "Urgent Stabilization",
      "RESTORE_REPLACE": "Restore/Replace",
      "PROTECT_BASE": "Protect Base",
      "DIRECT_ACCESS_PARITY": "Direct Access Parity",
      "EXPAND_STRENGTHEN": "Expand and Strengthen",
    }

    Rule priority (first match wins): LOGIC-05 > LOGIC-01 > LOGIC-02 > LOGIC-03 > LOGIC-04

    Test cases (input -> expected output):

    LOGIC-05 -- Urgent Stabilization:
      Program with THREATENS edge where days_remaining <= 30 -> URGENT_STABILIZATION
      Program with THREATENS edge where days_remaining = 31 -> does NOT trigger LOGIC-05
      Program matching LOGIC-01 AND LOGIC-05 -> URGENT_STABILIZATION wins (override)

    LOGIC-01 -- Restore/Replace:
      Program with ci_status="TERMINATED" and AUTHORIZED_BY edge to authority with durability containing "permanent" -> RESTORE_REPLACE
      Program with ci_status="FLAGGED" and active authority -> RESTORE_REPLACE (FLAGGED treated as near-terminated)
      Program with ci_status="STABLE" -> does NOT trigger LOGIC-01

    LOGIC-02 -- Protect Base:
      Program with FUNDED_BY edge to FundingVehicleNode with funding_type="Discretionary" and scored_items containing "eliminate" or "reduce" signals in matched programs -> PROTECT_BASE
      Also triggers when ci_status is "AT_RISK" or "UNCERTAIN" with discretionary funding
      Program with mandatory funding -> does NOT trigger LOGIC-02

    LOGIC-03 -- Direct Access Parity:
      Program where access_type field (in program dict or graph node) indicates "state_pass_through" and barriers include high-severity administrative barriers -> DIRECT_ACCESS_PARITY
      Program with direct access -> does NOT trigger LOGIC-03

    LOGIC-04 -- Expand and Strengthen:
      Program with ci_status in ("STABLE", "SECURE", "STABLE_BUT_VULNERABLE") and access_type indicates "direct" or "set_aside" -> EXPAND_STRENGTHEN
      Program with ci_status="AT_RISK" -> does NOT trigger LOGIC-04

    Default:
      Program matching no rules -> advocacy_goal=None, rule=None, confidence="LOW", reason explains no match

    secondary_rules:
      After primary rule is determined, all other rules are still evaluated. Matches are collected into secondary_rules list.
      Example: Program is URGENT_STABILIZATION (primary) but also matches PROTECT_BASE -> secondary_rules=["LOGIC-02"]
  </behavior>
  <implementation>
    Create DecisionEngine class in src/analysis/decision_engine.py following the existing analysis module pattern (see relevance.py and change_detector.py for style).

    Constructor: __init__(self, config: dict, programs: dict) where programs is {pid: program_dict}. Read urgency_threshold_days from config.get("monitors", {}).get("decision_engine", {}).get("urgency_threshold_days", 30).

    Public method: classify_all(self, graph_data: dict, alerts: list) -> dict[str, dict]
    Iterates over self.programs, calls _classify_program for each, returns results dict.

    Private method: _classify_program(self, pid: str, program: dict, graph_data: dict, alerts: list) -> dict
    Evaluates all 5 rules, collects matches into a list, returns the highest-priority match as primary with remaining matches as secondary_rules.

    Five private rule methods, each returning a classification dict or None:
    - _check_urgent_stabilization(pid, graph_data, alerts): Query graph_data["edges"] for THREATENS edges targeting this pid with days_remaining <= urgency_threshold_days
    - _check_restore_replace(pid, program, graph_data): Check ci_status in ("TERMINATED", "FLAGGED"), then check AUTHORIZED_BY edges to authorities with "permanent" or "active" in durability
    - _check_protect_base(pid, program, graph_data, alerts): Check for discretionary funding (FUNDED_BY edges to FundingVehicleNode with funding_type containing "discretionary" OR program has funding_type field). Then check for eliminate/reduce signals in alerts or program status (AT_RISK, UNCERTAIN with discretionary).
    - _check_direct_access_parity(pid, program, graph_data): Check program access_type for "state_pass_through" or barriers with severity "High" and barrier_type "Administrative". This data comes from program dict fields and BLOCKED_BY edges.
    - _check_expand_strengthen(pid, program, graph_data): Check ci_status in ("STABLE", "SECURE", "STABLE_BUT_VULNERABLE") and access type is "direct" or "set_aside" or "tribal_set_aside".

    Helper: _get_edges_for_program(graph_data, pid, edge_type) -> list[dict] -- filters graph_data["edges"].

    Important implementation notes:
    - Programs in the inventory don't all have access_type or funding_type fields explicitly. The decision engine should infer from graph edges (FUNDED_BY -> check node's funding_type, BLOCKED_BY -> check barrier severity) and fall through gracefully when data is missing.
    - For LOGIC-02, "eliminate/reduce signals" means: alerts list contains alerts with program_id in program_ids, or graph has THREATENS edges, or ci_status is AT_RISK/UNCERTAIN with discretionary funding.
    - Use logging (import logging, logger = logging.getLogger(__name__)) to log each classification decision at DEBUG level.
  </implementation>
</feature>

<verification>
1. `python -m pytest tests/test_decision_engine.py -v` -- all tests pass
2. `python -c "from src.analysis.decision_engine import DecisionEngine, ADVOCACY_GOALS; print(ADVOCACY_GOALS)"` -- imports cleanly
3. Each of the 5 rules has at least one positive and one negative test case
4. Default/no-match case is tested
5. Priority ordering is tested (LOGIC-05 overrides LOGIC-01)
6. secondary_rules collection is tested
</verification>

<success_criteria>
- DecisionEngine.classify_all() returns a classification for every program in inventory
- All 5 rules correctly identify their target conditions
- Priority ordering is enforced (LOGIC-05 always wins when applicable)
- Programs matching no rules get a default classification with confidence="LOW"
- secondary_rules field provides transparency on multi-rule matches
- All tests pass with clear test names describing the scenario
</success_criteria>

<output>
After completion, create `.planning/phases/03-monitoring-logic/03-02-SUMMARY.md`
</output>
