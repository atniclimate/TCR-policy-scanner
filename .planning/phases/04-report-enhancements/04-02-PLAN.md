---
phase: 04-report-enhancements
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/reports/generator.py
autonomous: true

must_haves:
  truths:
    - "Each pipeline run appends a CI snapshot to outputs/.ci_history.json with timestamp and per-program scores"
    - "Duplicate timestamps are not appended (re-runs on same day are idempotent)"
    - "CI history is capped at 90 entries to prevent unbounded growth"
    - "LATEST-BRIEFING.md contains a CI Score Trends section showing score trajectories"
    - "With only 1 scan in history, the trends section shows a message about needing 2+ scans"
    - "With 2+ scans, the trends section shows a table with dates, scores, and delta indicators"
  artifacts:
    - path: "src/reports/generator.py"
      provides: "CI history persistence and trend formatting"
      contains: "_save_ci_snapshot"
    - path: "outputs/.ci_history.json"
      provides: "Append-only CI score history across scans"
  key_links:
    - from: "src/reports/generator.py"
      to: "outputs/.ci_history.json"
      via: "_save_ci_snapshot writes, _load_ci_history reads"
      pattern: "ci_history"
    - from: "src/reports/generator.py _build_markdown"
      to: "_format_ci_trends"
      via: "ci_history loaded and passed to trend formatter"
      pattern: "_format_ci_trends"
---

<objective>
Add CI score history tracking and trend visualization to the briefing.

Purpose: Tribal leaders need to see how program confidence indices change over time, not just the current snapshot. This plan adds an append-only CI history file that accumulates per-scan snapshots and a briefing section that renders score trajectories across the last N scans. This is RPT-04 -- the final requirement for Phase 4.

Output: A `_save_ci_snapshot()` / `_load_ci_history()` mechanism in ReportGenerator, a `_format_ci_trends()` section in the briefing, and the `outputs/.ci_history.json` persistence file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-report-enhancements/04-RESEARCH.md
@.planning/phases/04-report-enhancements/04-01-SUMMARY.md

@src/reports/generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CI history persistence and trend formatting</name>
  <files>src/reports/generator.py</files>
  <action>
Add three components to the existing ReportGenerator class in src/reports/generator.py:

1. **Add CI_HISTORY_PATH constant** at module level (near existing OUTPUTS_DIR/ARCHIVE_DIR):
   ```python
   CI_HISTORY_PATH = OUTPUTS_DIR / ".ci_history.json"
   ```

2. **Add _save_ci_snapshot(self, timestamp: str) -> None**:
   - Build a snapshot dict: `{"timestamp": timestamp, "programs": {pid: {"ci": prog.get("confidence_index"), "status": prog.get("ci_status")} for pid, prog in self.programs.items()}}`
   - Load existing history via `_load_ci_history()`.
   - Check if `timestamp` already exists in history (de-duplicate on same-day re-runs).
   - If new, append the snapshot.
   - **Cap history at 90 entries** -- if len(history) > 90, trim oldest entries (`history = history[-90:]`). This prevents unbounded growth per Pitfall 3 in RESEARCH.md.
   - Write back to CI_HISTORY_PATH with `json.dump(history, f, indent=2)`.
   - Log the save: `logger.info("CI snapshot saved (%d entries in history)", len(history))`

3. **Add _load_ci_history(self) -> list[dict]**:
   - If CI_HISTORY_PATH does not exist, return `[]`.
   - Try to load with `json.load()`. On `JSONDecodeError` or `OSError`, log warning and return `[]`.
   - Follow the code example in 04-RESEARCH.md Pattern 5.

4. **Add _format_ci_trends(self, ci_history: list[dict]) -> list[str]** (RPT-04):
   - Always render the H2 header "## CI Score Trends".
   - If `len(ci_history) < 2`: show "*Trend data requires at least 2 scan cycles. Current: N scan(s).*" and return.
   - Show last 10 scans max: `recent = ci_history[-10:]`.
   - Show tracking info: "*Tracking N scan(s). Showing last M.*"
   - Build a table with columns: `| Program | date1 | date2 | ... | Trend |`
   - For each program in sorted latest_pids:
     - Look up CI score from each scan in `recent`. Show as percentage (e.g., "85%") or "--" if missing.
     - Calculate trend: compare first and last CI in the window. If delta > 0.02: "+N%". If delta < -0.02: "-N%". Otherwise: "STABLE".
   - Group programs meaningfully: show programs where CI actually changed first, then stable programs. If a program has no changes across the entire window, show it in a compact "Stable programs" summary line instead of a full row (per Research Open Question 3).
   - Follow the code example in 04-RESEARCH.md Example 6, but add the grouping enhancement.

5. **Wire into generate() and _build_markdown()**:
   - In `generate()`, BEFORE calling `_build_markdown()`:
     - Call `self._save_ci_snapshot(timestamp)` to persist the current scan's CI scores.
     - Call `ci_history = self._load_ci_history()` to get the full history.
   - Pass `ci_history` to `_build_markdown()` (add parameter).
   - In `_build_markdown()`, call `self._format_ci_trends(ci_history)` and insert the result after the Advocacy Levers section and before "All Relevant Items" (near end of briefing, as reference data per RESEARCH.md section ordering position 14).
  </action>
  <verify>
Run `python -c "from src.reports.generator import ReportGenerator; r = ReportGenerator([]); print('OK')"` to verify import succeeds.

Run `python -c "
import inspect
from src.reports.generator import ReportGenerator
methods = dir(ReportGenerator)
required = ['_save_ci_snapshot', '_load_ci_history', '_format_ci_trends']
for m in required:
    assert m in methods, f'Missing method: {m}'
print('All CI trend methods present')
"` to verify methods exist.
  </verify>
  <done>
ReportGenerator has _save_ci_snapshot (with 90-entry cap and dedup), _load_ci_history (with error handling), and _format_ci_trends (with grouping and delta indicators). The generate() method saves a snapshot before building the report and passes ci_history to _build_markdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate end-to-end CI trend tracking with pipeline run</name>
  <files>outputs/.ci_history.json</files>
  <action>
1. **Run the pipeline twice** with --report-only to create 2 history entries (different timestamps needed for trend table to render):
   ```
   python -m src.main --report-only
   ```
   This will create the first entry in .ci_history.json.

   Since --report-only uses `datetime.utcnow()` which produces the same date within a day, and _save_ci_snapshot deduplicates by timestamp, we need to verify the single-scan message appears first. Then manually seed a second entry to test the trend table.

2. **Verify .ci_history.json was created** with correct structure:
   ```python
   import json
   history = json.load(open('outputs/.ci_history.json'))
   assert len(history) >= 1, f'Expected at least 1 entry, got {len(history)}'
   entry = history[0]
   assert 'timestamp' in entry
   assert 'programs' in entry
   assert len(entry['programs']) > 0
   print(f'History has {len(history)} entries with {len(entry["programs"])} programs')
   ```

3. **Verify LATEST-BRIEFING.md contains CI Score Trends section**:
   - With 1 entry, should show the "requires at least 2 scan cycles" message.

4. **Seed a second history entry** to test trend table rendering:
   ```python
   import json
   history = json.load(open('outputs/.ci_history.json'))
   # Create a synthetic prior-day entry with slightly different CIs
   prior = {
       "timestamp": "2026-02-08",
       "programs": {}
   }
   for pid, data in history[-1]["programs"].items():
       ci = data.get("ci")
       # Shift CIs slightly to create visible deltas
       prior["programs"][pid] = {
           "ci": round(ci - 0.02, 4) if ci is not None else None,
           "status": data.get("status")
       }
   history.insert(0, prior)  # Insert at beginning (older entry)
   with open('outputs/.ci_history.json', 'w') as f:
       json.dump(history, f, indent=2)
   ```

5. **Re-run --report-only** to regenerate the briefing with 2+ history entries.

6. **Verify the trend table renders** in LATEST-BRIEFING.md with program rows, date columns, CI percentages, and trend indicators.
  </action>
  <verify>
Run `python -m src.main --report-only` and confirm exit code 0.

Then verify:
```python
python -c "
import json

# Verify history file
history = json.load(open('outputs/.ci_history.json'))
assert len(history) >= 2, f'Expected 2+ entries, got {len(history)}'
print(f'CI history: {len(history)} entries')

# Verify briefing has trend section with table
content = open('outputs/LATEST-BRIEFING.md').read()
assert 'CI Score Trends' in content, 'Missing CI Score Trends section'

# With 2+ entries, should have a table (pipe characters in trend section)
trend_start = content.index('## CI Score Trends')
trend_section = content[trend_start:trend_start+2000]
assert '|' in trend_section, 'CI Trends section should have a table with 2+ entries'
assert 'Trend' in trend_section, 'Table should have Trend column'
print('CI Score Trends section present with table')

# Verify all Phase 4 sections present
all_sections = [
    'Five Structural Asks', 'IIJA Sunset Countdown',
    'Reconciliation Watch', 'Advocacy Goal Classifications',
    'Hot Sheets', 'CI Score Trends'
]
missing = [s for s in all_sections if s not in content]
if missing:
    print(f'WARNING: Missing sections: {missing}')
else:
    print(f'All {len(all_sections)} Phase 4 sections present in LATEST-BRIEFING.md')
"
```
  </verify>
  <done>
Running the pipeline creates/appends to outputs/.ci_history.json. With 2+ entries, LATEST-BRIEFING.md shows a CI Score Trends table with per-program score trajectories and delta indicators. The history file is capped at 90 entries. All 6 Phase 4 sections (RPT-01 through RPT-06) are present in the final briefing.
  </done>
</task>

</tasks>

<verification>
1. `python -m src.main --report-only` completes without errors
2. outputs/.ci_history.json exists with valid JSON structure (list of snapshots)
3. Each snapshot has `timestamp` and `programs` dict with per-program `ci` and `status`
4. Duplicate timestamps are not appended on re-runs
5. LATEST-BRIEFING.md contains "## CI Score Trends" section
6. With 1 scan entry: shows "requires at least 2 scan cycles" message
7. With 2+ scan entries: shows table with dates, CI percentages, and trend indicators
8. All 6 Phase 4 sections present in LATEST-BRIEFING.md (completing RPT-01 through RPT-06)
</verification>

<success_criteria>
- outputs/.ci_history.json accumulates per-scan snapshots with 90-entry cap
- CI Score Trends section renders a table with score trajectories when 2+ scans exist
- Trend indicators show +N%, -N%, or STABLE based on first-to-last CI delta
- Programs with no changes across the window are shown in compact format
- All 6 RPT requirements (RPT-01 through RPT-06) are satisfied across Plans 01 and 02
- LATEST-BRIEFING.md is a complete advocacy intelligence product
</success_criteria>

<output>
After completion, create `.planning/phases/04-report-enhancements/04-02-SUMMARY.md`
</output>
