---
phase: 05-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/build_registry.py
  - src/packets/registry.py
  - data/tribal_registry.json
autonomous: true

must_haves:
  truths:
    - "build_registry.py fetches ~574 Tribes from EPA API in a single call with tribalBandFilter=AllTribes"
    - "tribal_registry.json contains ~574 Tribe records with no duplicate IDs"
    - "Each Tribe has epa_id (universal primary key), bia_code (optional), name, states, and alternate_names"
    - "Alaska Native entities have valid epa_id even though bia_code is TBD"
    - "TribalRegistry.resolve() finds Tribes by exact name, substring match, and fuzzy fallback"
    - "Lumbee Tribe absence is logged as a warning, not an error"
  artifacts:
    - path: "scripts/build_registry.py"
      provides: "One-time EPA API fetcher that builds tribal_registry.json"
    - path: "src/packets/registry.py"
      provides: "TribalRegistry class with lazy loading and 3-tier name resolution"
      exports: ["TribalRegistry"]
    - path: "data/tribal_registry.json"
      provides: "575-Tribe registry with identity, states, alternate names"
  key_links:
    - from: "scripts/build_registry.py"
      to: "https://cdxapi.epa.gov/oms-tribes-rest-services/api/v1/tribeDetails"
      via: "aiohttp GET with tribalBandFilter=AllTribes"
      pattern: "tribalBandFilter.*AllTribes"
    - from: "src/packets/registry.py"
      to: "data/tribal_registry.json"
      via: "Lazy-loads JSON file on first access"
      pattern: "tribal_registry\\.json"
    - from: "src/packets/registry.py"
      to: "rapidfuzz"
      via: "Tier 3 fuzzy matching import"
      pattern: "from rapidfuzz import"
---

<objective>
Build the Tribal registry data layer (REG-01) with both the one-time build script that fetches from the EPA Tribes Names Service API and the runtime TribalRegistry class that provides lazy-loaded 3-tier name resolution (exact -> substring -> fuzzy). This delivers the canonical list of all ~574 federally recognized Tribes with identity data.

Purpose: The registry is the foundation of the entire v1.1 milestone. Every downstream module (congressional mapping, award matching, hazard profiling, DOCX generation) starts with "which Tribe?" The registry answers that question and provides fuzzy search for user-facing name resolution.
Output: `scripts/build_registry.py` (run once), `data/tribal_registry.json` (cached data), `src/packets/registry.py` (runtime module).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-foundation/05-RESEARCH.md
@.planning/phases/05-foundation/05-CONTEXT.md
@src/scrapers/base.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build_registry.py script (EPA API -> tribal_registry.json)</name>
  <files>
    scripts/build_registry.py
    data/tribal_registry.json
  </files>
  <action>
Create `scripts/` directory if it does not exist.

Create `scripts/build_registry.py` — a standalone async script that:

1. **Fetches all Tribes from EPA Tribes Names Service API:**
   - URL: `https://cdxapi.epa.gov/oms-tribes-rest-services/api/v1/tribeDetails`
   - Params: `tribalBandFilter=AllTribes` (CRITICAL: without this, only ~260 records returned)
   - No authentication required
   - Single call returns ~574 records as a JSON array

2. **Transforms each EPA record into a standardized Tribe object:**
   ```python
   {
       "tribe_id": f"epa_{record['epaTribalInternalId']}",  # Universal primary key
       "bia_code": record.get("currentBIATribalCode", ""),   # Optional, "TBD" for Alaska
       "name": record.get("tribalName", ""),                 # Official BIA name
       "states": extract_states(record),                      # List of state abbreviations
       "alternate_names": extract_alternates(record),          # Historical/variant names for search
       "epa_region": record.get("epaRegionNumber", ""),
       "tribal_band_flag": record.get("tribalBandFlag", ""),
       "website": record.get("websiteUrl", ""),
   }
   ```

3. **State extraction logic:**
   - Parse the `tribalName` field for state abbreviations after commas (e.g., "Navajo Nation, Arizona, New Mexico, & Utah" -> ["AZ", "NM", "UT"])
   - Also check `state` or `stateCode` fields if present in the EPA response
   - Map full state names to abbreviations using a STATE_NAME_TO_ABBR dict
   - Handle the "&" separator in EPA names (e.g., "Arizona, New Mexico, & Utah")

4. **Alternate name extraction:**
   - Check for `historicalTribalNames` or similar fields in the EPA response
   - Store as a flat list of strings for search corpus
   - Include any "also known as" variants

5. **Validation:**
   - Assert no duplicate `tribe_id` values
   - Log count of Tribes with `bia_code == "TBD"` (expected: ~230 for Alaska)
   - Log warning if total count < 570 (expected ~574)
   - Log warning if "Lumbee" not found (Pitfall 6: recently added, may not be in EPA data yet)

6. **Write output using atomic write pattern:**
   ```python
   tmp_path = output_path.with_suffix(".tmp")
   with open(tmp_path, "w", encoding="utf-8") as f:
       json.dump(data, f, indent=2, ensure_ascii=False)
   tmp_path.replace(output_path)
   ```

7. **Output format** (`data/tribal_registry.json`):
   ```json
   {
       "metadata": {
           "source": "EPA Tribes Names Service API",
           "source_url": "https://cdxapi.epa.gov/oms-tribes-rest-services/api/v1/tribeDetails",
           "fetched_at": "2026-02-10T...",
           "total_tribes": 574,
           "bia_tbd_count": 230,
           "version": "1.0"
       },
       "tribes": [
           { "tribe_id": "epa_100000171", "bia_code": "04", "name": "Navajo Nation", ... },
           ...
       ]
   }
   ```

8. **Script entry point:**
   ```python
   if __name__ == "__main__":
       asyncio.run(main())
   ```

   With argparse for `--output` (default: `data/tribal_registry.json`) and `--verbose`.

Use `aiohttp` for the HTTP call (existing dependency). Use `encoding="utf-8"` everywhere. Use `logging.getLogger("tcr_scanner.build_registry")`. Handle HTTP errors gracefully with retries (2 attempts with 5s delay — the EPA API is known to be reliable but may have brief outages).

**IMPORTANT:** After creating the script, run it to generate the actual `data/tribal_registry.json`:
```bash
python scripts/build_registry.py --verbose
```

If the EPA API is unreachable (network issues), create a minimal placeholder `data/tribal_registry.json` with the correct schema and a `"placeholder": true` flag in metadata, plus at least 5 representative Tribe entries (Navajo Nation, Cherokee Nation, Tlingit & Haida, Seminole, Choctaw Nation of Oklahoma) for downstream testing. Log a warning that the placeholder must be replaced by running the build script when connectivity is available.
  </action>
  <verify>
    - `python scripts/build_registry.py --verbose` runs without error (or placeholder created if API unreachable)
    - `data/tribal_registry.json` exists and is valid JSON
    - `python -c "import json; d=json.load(open('data/tribal_registry.json', encoding='utf-8')); print(f'Tribes: {len(d[\"tribes\"])}')"` prints count >= 5 (full: ~574)
    - No duplicate tribe_id values: `python -c "import json; d=json.load(open('data/tribal_registry.json', encoding='utf-8')); ids=[t['tribe_id'] for t in d['tribes']]; print(f'Unique: {len(set(ids))}, Total: {len(ids)}, Dups: {len(ids)-len(set(ids))}')"` shows 0 dups
    - Alaska entries have valid epa_id (not "bia_TBD"): check any tribe with states containing "AK"
  </verify>
  <done>
    build_registry.py fetches from EPA API (or creates placeholder), writes tribal_registry.json with ~574 Tribes, each having a valid epa_id primary key. Alaska Natives have bia_code="TBD" but valid tribe_id. No duplicates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TribalRegistry runtime module with 3-tier name resolution</name>
  <files>
    src/packets/registry.py
  </files>
  <action>
Create `src/packets/registry.py` — the runtime module that loads `tribal_registry.json` and provides name resolution.

Class `TribalRegistry`:

1. **`__init__(self, config: dict)`**
   - Read `data_path` from `config.get("packets", {}).get("tribal_registry", {}).get("data_path", "data/tribal_registry.json")`
   - Initialize `self._tribes: list[dict] = []`, `self._loaded = False`
   - Use `logging.getLogger("tcr_scanner.packets.registry")`

2. **`_load(self) -> None`** (lazy loading)
   - If already loaded, return immediately
   - Open `self.data_path` with `encoding="utf-8"`, parse JSON
   - Store `data["tribes"]` in `self._tribes`
   - Log `"Loaded %d Tribes from %s"` (info level)
   - Set `self._loaded = True`

3. **`resolve(self, query: str) -> dict | list[dict] | None`** (3-tier resolution)
   - Call `self._load()`
   - Normalize query: `q = query.strip().lower()`

   **Tier 1 — Exact match on official name:**
   ```python
   for tribe in self._tribes:
       if tribe["name"].lower() == q:
           return tribe
   ```

   **Tier 2 — Substring match across name + alternate_names:**
   ```python
   candidates = []
   for tribe in self._tribes:
       searchable = [tribe["name"]] + tribe.get("alternate_names", [])
       for name in searchable:
           if q in name.lower():
               candidates.append(tribe)
               break
   if len(candidates) == 1:
       return candidates[0]  # Unambiguous substring
   if candidates:
       return candidates  # Ambiguous — caller decides
   ```

   **Tier 3 — Fuzzy fallback (rapidfuzz):**
   ```python
   from rapidfuzz import fuzz, process
   corpus = self._build_search_corpus()  # [(searchable_name, tribe_index), ...]
   results = process.extract(q, [c[0] for c in corpus], scorer=fuzz.token_sort_ratio, limit=5, score_cutoff=60)
   if results:
       matched = []
       for name, score, idx in results:
           tribe = self._tribes[corpus[idx][1]]  # Map back to tribe record
           matched.append({**tribe, "_match_score": score, "_matched_name": name})
       return matched  # List of fuzzy matches with scores
   ```

   Return `None` if no matches at any tier.

4. **`fuzzy_search(self, query: str, limit: int = 5) -> list[dict]`**
   - Direct fuzzy search (skipping exact/substring) for suggestion purposes
   - Returns list of `{...tribe_data, "_match_score": float, "_matched_name": str}`

5. **`get_all(self) -> list[dict]`**
   - Returns all Tribes (calls `self._load()` first)

6. **`get_by_id(self, tribe_id: str) -> dict | None`**
   - Lookup by `tribe_id` field

7. **`_build_search_corpus(self) -> list[tuple[str, int]]`**
   - Builds `[(searchable_name, tribe_index), ...]` from all names + alternates
   - Each Tribe may contribute multiple entries (one per name variant)
   - Cache the corpus after first build for performance

**Implementation notes:**
- rapidfuzz is imported lazily inside Tier 3 methods (not at module level) to avoid import cost when exact/substring matches succeed
- Use `encoding="utf-8"` on all file operations
- All methods are synchronous (registry is pre-built, not fetched at runtime)
- Do NOT use `datetime.utcnow()` — use `datetime.now(timezone.utc)` if timestamps needed
  </action>
  <verify>
    - `python -c "from src.packets.registry import TribalRegistry; r = TribalRegistry({}); print(type(r))"` succeeds
    - If tribal_registry.json has real data:
      - `python -c "from src.packets.registry import TribalRegistry; r = TribalRegistry({}); t = r.resolve('Navajo Nation'); print(t['name'] if isinstance(t, dict) else 'list')"` returns "Navajo Nation" (exact match)
      - `python -c "from src.packets.registry import TribalRegistry; r = TribalRegistry({}); t = r.resolve('Choctaw'); print(type(t), len(t) if isinstance(t, list) else 'single')"` returns list (substring matches multiple Choctaw Tribes)
      - `python -c "from src.packets.registry import TribalRegistry; r = TribalRegistry({}); t = r.resolve('Tlingit'); print(type(t))"` returns some result (fuzzy or substring)
      - `python -c "from src.packets.registry import TribalRegistry; r = TribalRegistry({}); print(len(r.get_all()))"` prints count matching tribal_registry.json
    - If tribal_registry.json has placeholder data:
      - Same tests with the 5 representative Tribes
  </verify>
  <done>
    TribalRegistry lazily loads tribal_registry.json, provides exact/substring/fuzzy name resolution across official names and alternate names. resolve() returns a single dict (exact), list of dicts (ambiguous/fuzzy), or None (no match). All Tribes accessible via get_all() and get_by_id().
  </done>
</task>

</tasks>

<verification>
1. `scripts/build_registry.py` exists and is executable
2. `data/tribal_registry.json` exists with valid schema and >= 5 Tribes
3. `from src.packets.registry import TribalRegistry` works
4. Name resolution works for at least: "Navajo Nation" (exact), "Choctaw" (substring/ambiguous), "Tlingit" (fuzzy or substring)
5. No duplicate tribe_id in registry
6. Alaska Natives have valid tribe_id starting with "epa_"
</verification>

<success_criteria>
- EPA API data fetched (or placeholder created) with ~574 Tribes
- TribalRegistry provides all 3 resolution tiers working correctly
- No BIA code used as primary key (epa_id is universal)
- Registry data is UTF-8 safe (Tribe names with apostrophes like "Coeur d'Alene" preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation/05-02-SUMMARY.md`
</output>
