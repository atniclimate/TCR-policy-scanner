---
phase: 11-api-resilience
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/scrapers/circuit_breaker.py
  - src/scrapers/base.py
  - config/scanner_config.json
  - tests/test_circuit_breaker.py
autonomous: true

must_haves:
  truths:
    - "CircuitBreaker transitions CLOSED -> OPEN after failure_threshold consecutive failures"
    - "CircuitBreaker transitions OPEN -> HALF_OPEN after recovery_timeout elapses"
    - "CircuitBreaker transitions HALF_OPEN -> CLOSED on successful probe"
    - "CircuitBreaker transitions HALF_OPEN -> OPEN on failed probe"
    - "CircuitOpenError is raised when a call is attempted on an OPEN breaker"
    - "BaseScraper reads retry/backoff/circuit-breaker config from scanner_config.json resilience section"
    - "Omitting the resilience section produces identical behavior to current hardcoded defaults"
    - "All 4 scraper subclasses pass config up to BaseScraper for circuit breaker initialization"
  artifacts:
    - path: "src/scrapers/circuit_breaker.py"
      provides: "CircuitBreaker class, CircuitState enum, CircuitOpenError exception"
      min_lines: 80
    - path: "tests/test_circuit_breaker.py"
      provides: "15+ tests for state transitions, timing, config integration"
      min_lines: 150
  key_links:
    - from: "src/scrapers/base.py"
      to: "src/scrapers/circuit_breaker.py"
      via: "import CircuitBreaker, CircuitOpenError; self._circuit_breaker in __init__"
      pattern: "from src\\.scrapers\\.circuit_breaker import"
    - from: "src/scrapers/base.py"
      to: "config/scanner_config.json"
      via: "resilience config dict passed to __init__"
      pattern: "resilience.*get"
    - from: "src/scrapers/federal_register.py"
      to: "src/scrapers/base.py"
      via: "super().__init__ now receives config"
      pattern: "super\\(\\).__init__.*config"
---

<objective>
Implement the circuit breaker state machine and integrate it into BaseScraper with configurable retry/backoff parameters.

Purpose: RESL-01 (circuit breaker pattern) and RESL-02 (configurable retry/backoff) -- the two foundational requirements that all other resilience features build on. Without this, the pipeline has no way to fail fast on downed APIs or tune retry behavior per environment.

Output: `src/scrapers/circuit_breaker.py` with CircuitBreaker class, updated `BaseScraper` with config-driven parameters and circuit breaker integration, updated `scanner_config.json` with resilience section, and 15+ tests proving all state transitions.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-api-resilience/11-RESEARCH.md

@src/scrapers/base.py
@src/scrapers/federal_register.py
@src/scrapers/grants_gov.py
@src/scrapers/congress_gov.py
@src/scrapers/usaspending.py
@config/scanner_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create circuit_breaker.py with CircuitBreaker class + tests</name>
  <files>
    src/scrapers/circuit_breaker.py
    tests/test_circuit_breaker.py
  </files>
  <action>
    **RED phase -- write tests first, then GREEN -- implement to pass.**

    Create `src/scrapers/circuit_breaker.py` containing:

    1. `CircuitState` enum with three values: `CLOSED`, `OPEN`, `HALF_OPEN`.

    2. `CircuitOpenError(Exception)` -- raised when a call is attempted on an OPEN circuit. Include the source name and a human-readable message.

    3. `CircuitBreaker` class with constructor:
       ```python
       def __init__(
           self,
           name: str,
           failure_threshold: int = 5,
           recovery_timeout: float = 60.0,
           clock: Callable[[], float] | None = None,
       ):
       ```
       - `clock` defaults to `time.monotonic` if not provided. This enables deterministic testing.
       - Internal state: `_state` (CircuitState.CLOSED), `_failure_count` (0), `_last_failure_time` (0.0), `_success_count` (0).

    4. `state` property that checks OPEN -> HALF_OPEN transition based on `recovery_timeout` elapsed since `_last_failure_time`. Uses `self._clock()` not `time.monotonic()` directly.

    5. `record_success()` method: resets failure count. If HALF_OPEN, transitions to CLOSED. Logs info on recovery.

    6. `record_failure()` method: increments failure count, records time. If HALF_OPEN, transitions to OPEN. If failure_count >= threshold, transitions to OPEN. Logs warning on trip.

    7. `is_call_permitted` property: returns True if state is CLOSED or HALF_OPEN.

    8. `reset()` method: resets to CLOSED state with zero counters (useful for testing and health checks).

    Use `logging.getLogger(__name__)` for all logging.

    Create `tests/test_circuit_breaker.py` with a `MockClock` helper class and at least 15 tests:

    - `test_initial_state_is_closed` -- new breaker is CLOSED
    - `test_stays_closed_below_threshold` -- N-1 failures keeps CLOSED
    - `test_opens_at_threshold` -- N failures transitions to OPEN
    - `test_open_blocks_calls` -- is_call_permitted returns False when OPEN
    - `test_closed_permits_calls` -- is_call_permitted returns True when CLOSED
    - `test_half_open_permits_calls` -- is_call_permitted returns True when HALF_OPEN
    - `test_open_to_half_open_after_timeout` -- state transitions after recovery_timeout
    - `test_stays_open_before_timeout` -- state stays OPEN before recovery_timeout
    - `test_half_open_to_closed_on_success` -- record_success in HALF_OPEN -> CLOSED
    - `test_half_open_to_open_on_failure` -- record_failure in HALF_OPEN -> OPEN
    - `test_success_resets_failure_count` -- record_success resets counter
    - `test_circuit_open_error_message` -- CircuitOpenError includes name
    - `test_custom_threshold` -- non-default failure_threshold works
    - `test_custom_recovery_timeout` -- non-default timeout works
    - `test_reset_returns_to_closed` -- reset() clears state
    - `test_multiple_recovery_cycles` -- CLOSED -> OPEN -> HALF_OPEN -> CLOSED -> OPEN cycle

    All tests use `MockClock` with `advance()` method for deterministic timing. Zero real sleeps.
  </action>
  <verify>
    ```bash
    python -m pytest tests/test_circuit_breaker.py -v
    ```
    All 15+ tests pass. No warnings about missing imports.
  </verify>
  <done>
    CircuitBreaker class with 3-state machine, injectable clock, CircuitOpenError exception, and 15+ passing tests with 100% state transition coverage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate circuit breaker into BaseScraper + config</name>
  <files>
    src/scrapers/base.py
    src/scrapers/federal_register.py
    src/scrapers/grants_gov.py
    src/scrapers/congress_gov.py
    src/scrapers/usaspending.py
    config/scanner_config.json
    tests/test_circuit_breaker.py
  </files>
  <action>
    **Modify `BaseScraper.__init__`** to accept an optional `config` parameter and initialize a circuit breaker:

    ```python
    def __init__(self, source_name: str, config: dict | None = None):
        self.source_name = source_name
        self._headers = {"User-Agent": USER_AGENT}
        resilience = (config or {}).get("resilience", {})
        self.max_retries = resilience.get("max_retries", MAX_RETRIES)
        self.backoff_base = resilience.get("backoff_base", BACKOFF_BASE)
        self.backoff_max = resilience.get("backoff_max", 300)
        self.request_timeout = aiohttp.ClientTimeout(
            total=resilience.get("request_timeout", 30)
        )
        cb_config = resilience.get("circuit_breaker", {})
        self._circuit_breaker = CircuitBreaker(
            name=source_name,
            failure_threshold=cb_config.get("failure_threshold", 5),
            recovery_timeout=cb_config.get("recovery_timeout", 60),
        )
    ```

    **Modify `_request_with_retry`** to:
    - Use `self.max_retries` instead of `MAX_RETRIES` default for the `retries` parameter.
    - Use `self.backoff_base` instead of `BACKOFF_BASE` for backoff calculation.
    - Use `self.backoff_max` for the ceiling in rate-limit and backoff calculations (replace hardcoded `300`).
    - Use `self.request_timeout` in `kwargs.setdefault("timeout", self.request_timeout)`.
    - Add circuit breaker check at the top: if `not self._circuit_breaker.is_call_permitted`, raise `CircuitOpenError(...)`.
    - After a successful response (`return await resp.json()`), call `self._circuit_breaker.record_success()`.
    - In the final error block (all retries exhausted), call `self._circuit_breaker.record_failure()` before raising.

    **IMPORTANT for circuit breaker placement:** The circuit breaker wraps the ENTIRE retry loop, not individual attempts. The check happens once at entry. `record_failure()` is called only when ALL retries are exhausted. `record_success()` is called on any successful response. This matches the research recommendation: "retries happen inside CLOSED state; the breaker trips when all retries are exhausted."

    **Update all 4 scraper subclasses** to pass `config` up to BaseScraper:
    - `FederalRegisterScraper.__init__`: change `super().__init__("federal_register")` to `super().__init__("federal_register", config=config)`
    - `GrantsGovScraper.__init__`: change `super().__init__("grants_gov")` to `super().__init__("grants_gov", config=config)`
    - `CongressGovScraper.__init__`: change `super().__init__("congress_gov")` to `super().__init__("congress_gov", config=config)`
    - `USASpendingScraper.__init__`: change `super().__init__("usaspending")` to `super().__init__("usaspending", config=config)`

    **Add `resilience` section to `scanner_config.json`:**
    ```json
    "resilience": {
      "max_retries": 3,
      "backoff_base": 2,
      "backoff_max": 300,
      "request_timeout": 30,
      "circuit_breaker": {
        "failure_threshold": 5,
        "recovery_timeout": 60
      }
    }
    ```
    Place it after the `"scan_window_days"` key and before the `"monitors"` key.

    **Add integration tests** to `tests/test_circuit_breaker.py`:
    - `test_base_scraper_creates_circuit_breaker` -- BaseScraper with config creates a breaker with config values
    - `test_base_scraper_defaults_without_config` -- BaseScraper with no config uses hardcoded defaults
    - `test_base_scraper_defaults_without_resilience_section` -- BaseScraper with config dict that has no "resilience" key uses defaults
    - `test_config_overrides_retry_params` -- max_retries, backoff_base from config are used

    **Do NOT change:** The module-level constants `MAX_RETRIES`, `BACKOFF_BASE`, `DEFAULT_TIMEOUT` -- they serve as defaults when no config is provided. Keep them for backward compatibility.
  </action>
  <verify>
    ```bash
    python -m pytest tests/test_circuit_breaker.py -v
    python -m pytest tests/ -v --tb=short
    ruff check src/scrapers/base.py src/scrapers/circuit_breaker.py
    ```
    All circuit breaker tests pass. Full test suite passes. No ruff violations.
  </verify>
  <done>
    BaseScraper reads resilience config from scanner_config.json, creates a per-source CircuitBreaker, and uses it to fail fast on OPEN circuits. All 4 subclasses pass config to parent. Omitting config produces identical behavior to current hardcoded values. RESL-01 and RESL-02 satisfied.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_circuit_breaker.py -v` -- 19+ tests pass (15 state machine + 4 integration)
2. `python -m pytest tests/ -v` -- full test suite passes with zero regressions
3. `ruff check .` -- zero violations
4. `python -c "from src.scrapers.circuit_breaker import CircuitBreaker, CircuitState, CircuitOpenError; print('OK')"` -- imports work
5. `python -c "from src.scrapers.base import BaseScraper; b = BaseScraper('test'); print(b._circuit_breaker.state)"` -- shows CircuitState.CLOSED
6. `python -c "import json; c = json.load(open('config/scanner_config.json')); print(c['resilience'])"` -- resilience section exists with expected keys
</verification>

<success_criteria>
- CircuitBreaker implements CLOSED/OPEN/HALF_OPEN state machine with all 4 transitions
- CircuitOpenError raised when call attempted on OPEN breaker
- Injectable clock enables deterministic testing (zero real sleeps in tests)
- BaseScraper reads max_retries, backoff_base, backoff_max, request_timeout, and circuit_breaker config from scanner_config.json
- All 4 scraper subclasses pass config to BaseScraper
- Config absence produces identical behavior to pre-change code (backward compatible)
- scanner_config.json has resilience section with documented defaults
- 19+ tests cover all state transitions and config integration
- Full test suite passes with zero regressions
- ruff check passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/11-api-resilience/11-01-SUMMARY.md`
</output>
