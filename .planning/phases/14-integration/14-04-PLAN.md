---
phase: 14-integration
plan: 04
type: execute
wave: 2
depends_on: ["14-01", "14-02"]
files_modified:
  - src/packets/regional.py
  - src/packets/context.py
  - src/packets/orchestrator.py
  - tests/test_regional.py
autonomous: true

must_haves:
  truths:
    - "RegionalContext aggregates award, hazard, and delegation data across all Tribes in a region"
    - "Orchestrator generates Doc C + Doc D for each of the 8 regions"
    - "Cross-cutting region aggregates data from all 592 Tribes"
    - "Regional docs surface delegation overlap (members serving multiple Tribes)"
  artifacts:
    - path: "src/packets/regional.py"
      provides: "RegionalAggregator class and RegionalContext dataclass"
      exports: ["RegionalAggregator", "RegionalContext"]
    - path: "tests/test_regional.py"
      provides: "Tests for regional aggregation and Doc C/D generation"
      min_lines: 50
  key_links:
    - from: "src/packets/regional.py"
      to: "data/regional_config.json"
      via: "RegionalAggregator loads region definitions"
      pattern: "regional_config"
    - from: "src/packets/orchestrator.py"
      to: "src/packets/regional.py"
      via: "Orchestrator calls RegionalAggregator then generates Doc C/D"
      pattern: "RegionalAggregator"
---

<objective>
Build the regional aggregation system and generate Doc C (InterTribal Strategy) and Doc D (Regional Congressional Overview) for all 8 regions.

Purpose: While Plan 14-03 handles per-Tribe Doc A/B, this plan builds the regional document layer. Doc C and Doc D aggregate data across all Tribes in a region to show shared hazards, collective economic impact, delegation overlap, and coverage gaps. This addresses INTG-02 for regional scope.

Output: RegionalAggregator produces RegionalContext per region; orchestrator generates Doc C + Doc D for all 8 regions; output in regional/internal/ and regional/congressional/ directories.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PHASE-14-REFERENCE.md
@.planning/PHASE-14-DESIGN-DECISIONS.md
@.planning/phases/14-integration/14-01-SUMMARY.md
@.planning/phases/14-integration/14-02-SUMMARY.md
@src/packets/context.py
@src/packets/orchestrator.py
@src/packets/doc_types.py
@data/regional_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RegionalAggregator and RegionalContext</name>
  <files>src/packets/regional.py, src/packets/context.py, tests/test_regional.py</files>
  <action>
  Create `src/packets/regional.py` with the regional data aggregation system.

  **RegionalContext dataclass** (add to context.py or regional.py -- keep in regional.py to avoid bloating context.py):
  ```python
  @dataclass
  class RegionalContext:
      region_id: str              # "pnw", "alaska", etc.
      region_name: str            # "Pacific Northwest / Columbia River Basin"
      short_name: str             # "Pacific Northwest"
      core_frame: str             # From regional_config.json
      treaty_trust_angle: str     # From regional_config.json
      key_programs: list[str]     # From regional_config.json
      states: list[str]           # States in region

      # Aggregated data
      tribe_count: int            # Number of Tribes in region
      tribes: list[dict]          # List of {tribe_id, tribe_name, states} for each Tribe
      total_awards: float         # Sum of all Tribe awards in region
      award_coverage: int         # Tribes with at least one award
      hazard_coverage: int        # Tribes with hazard data
      congressional_coverage: int # Tribes with delegation data

      # Composite hazard profile
      top_shared_hazards: list[dict]  # Hazards affecting most Tribes [{hazard_type, tribe_count, avg_score}]
      composite_risk_score: float     # Average risk score across Tribes with data

      # Economic aggregates
      aggregate_economic_impact: dict # {total_low, total_high, total_jobs_low, total_jobs_high}

      # Congressional overlap
      delegation_overlap: list[dict]  # Members serving multiple Tribes [{member_name, tribe_count, committees}]
      total_senators: int
      total_representatives: int

      # Coverage gaps
      tribes_without_awards: list[str]  # Tribe IDs with no awards
      tribes_without_hazards: list[str] # Tribe IDs with no hazard data
      tribes_without_delegation: list[str] # Tribe IDs with no congressional data

      # Metadata
      generated_at: str
  ```

  **RegionalAggregator class:**
  ```python
  class RegionalAggregator:
      def __init__(self, regional_config_path, registry, congressional_mapper):
          """Load regional config and prepare for aggregation."""
          self.config = json.loads(regional_config_path.read_text())
          self.registry = registry
          self.congressional = congressional_mapper

      def aggregate(self, region_id, tribe_contexts: list[TribePacketContext]) -> RegionalContext:
          """Aggregate multiple TribePacketContexts into a RegionalContext."""
          # For crosscutting: uses ALL tribe_contexts
          # For others: filters to Tribes whose states overlap with region's states

      def _assign_tribes_to_region(self, region_id) -> list[str]:
          """Return list of tribe_ids belonging to region based on state overlap."""
          region_states = set(self.config['regions'][region_id]['states'])
          if not region_states:  # crosscutting
              return [t['tribe_id'] for t in self.registry.tribes]
          return [t['tribe_id'] for t in self.registry.tribes
                  if set(t.get('states', [])) & region_states]

      def _aggregate_awards(self, contexts) -> tuple[float, int]:
          """Sum awards and count Tribes with awards."""

      def _find_shared_hazards(self, contexts) -> list[dict]:
          """Find hazards affecting the most Tribes in the region.
          Returns top 5 hazards ranked by number of Tribes affected."""

      def _find_delegation_overlap(self, contexts) -> list[dict]:
          """Find congressional members serving multiple Tribes.
          Returns members ranked by Tribe count."""

      def _aggregate_economics(self, contexts) -> dict:
          """Sum economic impact across all Tribes in region.
          Uses TribeEconomicSummary data from each context."""

      def _identify_gaps(self, contexts) -> tuple[list, list, list]:
          """Identify Tribes missing awards, hazards, or delegation data."""
  ```

  Key implementation details:
  - Tribes are assigned to regions by state overlap (Tribe.states intersects region.states)
  - A Tribe can appear in multiple regions if it spans multiple states
  - Cross-cutting region includes ALL Tribes (empty states list means all)
  - Shared hazards: count how many Tribes in the region have each hazard type in their top-5, rank by count
  - Delegation overlap: find bioguide_ids that appear in multiple Tribes' delegation, rank by Tribe count
  - Economic aggregation: sum the low/high ranges from each Tribe's economic summary

  **Tests (tests/test_regional.py):**
  1. `test_tribe_assignment_by_state`: Create mock Tribes in WA and AK, verify WA assigned to pnw and AK assigned to alaska
  2. `test_crosscutting_includes_all_tribes`: Verify crosscutting region includes all mock Tribes
  3. `test_award_aggregation`: Mock 3 Tribes with known awards, verify total matches sum
  4. `test_shared_hazard_detection`: Mock Tribes with overlapping hazards, verify shared hazards ranked correctly
  5. `test_delegation_overlap`: Mock Tribes sharing a senator, verify overlap detected
  6. `test_coverage_gap_identification`: Mix of complete and partial Tribes, verify gaps listed correctly
  7. `test_multi_state_tribe_assignment`: Tribe with states [WA, OR] assigned to pnw
  </action>
  <verify>
  1. `python -m pytest tests/test_regional.py -v` -- all new tests pass
  2. `python -c "from src.packets.regional import RegionalAggregator, RegionalContext; print('Import OK')"`
  3. `python -m pytest tests/ -x -q` -- full suite passes
  </verify>
  <done>RegionalAggregator loads regional config, assigns Tribes to regions, aggregates awards/hazards/delegation/economics, identifies coverage gaps; RegionalContext captures all aggregated data; tests verify all aggregation logic</done>
</task>

<task type="auto">
  <name>Task 2: Wire regional document generation into orchestrator</name>
  <files>src/packets/orchestrator.py</files>
  <action>
  Add regional document generation capability to PacketOrchestrator.

  1. Add `generate_regional_docs(self)` method:
     ```python
     def generate_regional_docs(self):
         """Generate Doc C + Doc D for all 8 regions.

         Pre-aggregates all Tribe contexts, then generates 2 docs per region.
         Returns dict of {region_id: [path_c, path_d]}.
         """
         # Step 1: Build all TribePacketContexts (reuse from Tribal generation or cache)
         all_contexts = {}
         for tribe in self.registry.tribes:
             ctx = self._build_context(tribe)
             all_contexts[tribe['tribe_id']] = ctx

         # Step 2: For each region, aggregate and generate
         aggregator = RegionalAggregator(
             REGIONAL_CONFIG_PATH, self.registry, self.congressional
         )
         results = {}
         for region_id in aggregator.config['regions']:
             # Get Tribe IDs for this region
             tribe_ids = aggregator._assign_tribes_to_region(region_id)
             region_contexts = [all_contexts[tid] for tid in tribe_ids if tid in all_contexts]

             # Aggregate
             regional_ctx = aggregator.aggregate(region_id, region_contexts)

             # Generate Doc C (internal)
             path_c = self._generate_regional_doc(regional_ctx, DOC_C)
             # Generate Doc D (congressional)
             path_d = self._generate_regional_doc(regional_ctx, DOC_D)

             results[region_id] = [path_c, path_d]
             logger.info(f"Regional docs for {region_id}: {len(region_contexts)} Tribes aggregated")

         return results
     ```

  2. Add `_generate_regional_doc(self, regional_ctx, doc_type_config)`:
     - Creates DocxEngine with doc_type_config
     - Adapts RegionalContext into a format the engine can render
     - For the generate() call, create a minimal TribePacketContext-like object or extend generate() to accept RegionalContext
     - Practical approach: Create a `generate_regional()` method on DocxEngine that accepts RegionalContext and doc_type_config. This method renders region-specific sections:
       * Cover page (region name, Tribe count, states)
       * Regional executive summary (aggregate data)
       * Regional hazard synthesis (shared hazards across Tribes)
       * Regional award landscape (aggregate awards, coverage gaps)
       * Program priorities by region (from regional_config key_programs)
       * Congressional delegation for region (with overlap analysis for Doc C, clean table for Doc D)
       * Structural policy asks (regional framing)
       * Appendix (Tribe list in region)
     - Save to `output_dir/regional/internal/{region_slug}_intertribal_strategy_fy26.docx` for Doc C
     - Save to `output_dir/regional/congressional/{region_slug}_congressional_overview_fy26.docx` for Doc D

  3. Update `run_all_tribes()` to also call `generate_regional_docs()` after Tribal doc generation. Add a `--skip-regional` CLI flag for faster testing.

  4. Add region-specific section rendering functions (can be minimal implementations that present the aggregated data -- the quality/narrative refinement is Plan 14-05):
     - `render_regional_cover_page(doc, regional_ctx, sm, doc_type_config)`
     - `render_regional_executive_summary(doc, regional_ctx, sm, doc_type_config)`
     - `render_regional_hazard_synthesis(doc, regional_ctx, sm)`
     - `render_regional_award_landscape(doc, regional_ctx, sm)`
     - `render_regional_delegation(doc, regional_ctx, sm, doc_type_config)` -- includes overlap analysis for Doc C, clean table for Doc D
     - `render_regional_appendix(doc, regional_ctx, sm)` -- lists all Tribes in region

  These can go in a new file `src/packets/docx_regional_sections.py` or at the bottom of `docx_sections.py`. Prefer a new file to keep things clean.

  The regional sections should use the same StyleManager and formatting patterns as Tribal sections. Use the `regional_ctx.core_frame` and `regional_ctx.treaty_trust_angle` from the config for ecoregion-specific narrative.

  IMPORTANT: Regional executive summary for Doc C (internal) should include:
  - "Federation not competition" framing operationalized through data
  - Coverage gap analysis (which Tribes have zero awards)
  - Delegation overlap as shared leverage opportunity

  Regional executive summary for Doc D (congressional) should be evidence-only:
  - Tribe count, state count, aggregate hazard profile
  - Total federal investment and economic impact
  - Framed as resource utilization report
  </action>
  <verify>
  1. `python -m pytest tests/test_regional.py -v` -- tests pass
  2. `python -m pytest tests/ -x -q` -- full suite passes
  3. Quick smoke test: `python -c "from src.packets.orchestrator import PacketOrchestrator; print('Import OK')"`
  </verify>
  <done>Orchestrator generates Doc C + Doc D for all 8 regions; regional sections present aggregated data with audience differentiation; output in regional/internal/ and regional/congressional/ directories</done>
</task>

</tasks>

<verification>
1. RegionalAggregator produces valid RegionalContext for all 8 regions
2. Doc C contains internal framing (coverage gaps, delegation overlap as leverage); Doc D is evidence-only
3. Cross-cutting region aggregates from all Tribes
4. Regional docs saved in correct directory structure
5. Full test suite passes (606+ existing + regional tests)
</verification>

<success_criteria>
- RegionalContext dataclass captures all aggregated data per region
- RegionalAggregator correctly assigns Tribes to regions by state overlap
- Doc C and Doc D generated for all 8 regions with audience differentiation
- Regional documents present aggregate awards, shared hazards, delegation overlap, economic impact
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-integration/14-04-SUMMARY.md`
</output>
