---
phase: 02-data-model-graph
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - data/graph_schema.json
  - src/graph/schema.py
  - src/graph/builder.py
autonomous: true

must_haves:
  truths:
    - "Running the graph builder produces AdvocacyLeverNodes for all 5 Structural Asks with ADVANCES edges to their connected programs"
    - "The graph contains a TrustSuperNode (FEDERAL_TRUST_RESPONSIBILITY) with TRUST_OBLIGATION edges to BIA and EPA Tribal programs"
    - "New edge types ADVANCES and TRUST_OBLIGATION appear in the serialized graph output"
    - "The pipeline runs end-to-end without errors after all graph changes"
  artifacts:
    - path: "data/graph_schema.json"
      provides: "Trust Super-Node JSON data for builder to consume"
      contains: "trust_super_node"
    - path: "src/graph/schema.py"
      provides: "TrustSuperNode dataclass for graph node serialization"
      contains: "class TrustSuperNode"
    - path: "src/graph/builder.py"
      provides: "Builder methods to load structural asks and Trust Super-Node from schema"
      contains: "_seed_structural_asks"
  key_links:
    - from: "src/graph/builder.py"
      to: "data/graph_schema.json"
      via: "_seed_structural_asks reads structural_asks array from schema"
      pattern: "schema\\.get\\(\"structural_asks\""
    - from: "src/graph/builder.py"
      to: "data/graph_schema.json"
      via: "_seed_trust_node reads trust_super_node object from schema"
      pattern: "schema\\.get\\(\"trust_super_node\""
    - from: "src/graph/builder.py"
      to: "src/graph/schema.py"
      via: "imports TrustSuperNode for node creation"
      pattern: "from src\\.graph\\.schema import.*TrustSuperNode"
    - from: "src/graph/builder.py"
      to: "ADVANCES edges"
      via: "structural ask -> program edges created in loop"
      pattern: "edge_type=\"ADVANCES\""
    - from: "src/graph/builder.py"
      to: "TRUST_OBLIGATION edges"
      via: "trust node -> program edges created in loop"
      pattern: "edge_type=\"TRUST_OBLIGATION\""
---

<objective>
Extend the graph builder to load Five Structural Asks as AdvocacyLeverNodes with ADVANCES edges, and implement the Trust Super-Node (FEDERAL_TRUST_RESPONSIBILITY) with TRUST_OBLIGATION edges to BIA/EPA programs.

Purpose: Completes GRAPH-01, GRAPH-02, and GRAPH-05 -- the graph builder enhancements that transform static JSON data into queryable graph relationships. The structural asks data already exists in graph_schema.json but the builder does not process it. The Trust Super-Node needs both JSON data and Python code.

Output: Updated builder.py with two new seeding methods, new TrustSuperNode class in schema.py, trust_super_node data in graph_schema.json. Pipeline produces a graph with ADVANCES and TRUST_OBLIGATION edges.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-model-graph/02-RESEARCH.md

@src/graph/schema.py
@src/graph/builder.py
@data/graph_schema.json
@data/program_inventory.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TrustSuperNode class and Trust Super-Node JSON data</name>
  <files>src/graph/schema.py, data/graph_schema.json</files>
  <action>
  Two changes -- one Python, one JSON:

  **1. Add TrustSuperNode dataclass to `src/graph/schema.py`:**

  Add after the `AdvocacyLeverNode` class (before `ObligationNode`):

  ```python
  @dataclass
  class TrustSuperNode:
      """Federal trust responsibility meta-node.

      Represents the overarching federal trust obligation to Tribal Nations,
      connecting to BIA and EPA programs that carry direct trust responsibility
      implications. Creates TRUST_OBLIGATION edges to connected programs.
      """
      id: str
      name: str
      description: str = ""
      legal_basis: str = ""
  ```

  Also update the Edge class docstring to include the two new edge types:
  ```
  Edge types:
    AUTHORIZED_BY   (Program -> Authority)
    FUNDED_BY       (Program -> FundingVehicle)
    BLOCKED_BY      (Program -> Barrier)
    MITIGATED_BY    (Barrier -> AdvocacyLever)
    OBLIGATED_BY    (Program -> ObligationNode)
    ADVANCES        (StructuralAsk -> Program)
    TRUST_OBLIGATION (TrustSuperNode -> Program)
  ```

  **2. Add trust_super_node object to `data/graph_schema.json`:**

  Add a new top-level key `"trust_super_node"` (alongside existing `"authorities"`, `"barriers"`, etc.):

  ```json
  "trust_super_node": {
    "id": "FEDERAL_TRUST_RESPONSIBILITY",
    "name": "Federal Trust Responsibility",
    "description": "The United States government's legal obligation to protect Tribal treaty rights, lands, assets, and resources, establishing a fiduciary duty that underpins all federal Tribal programs.",
    "legal_basis": "Cherokee Nation v. Georgia (1831), Seminole Nation v. United States (1942), Snyder Act (25 U.S.C. 13), Indian Self-Determination and Education Assistance Act (25 U.S.C. 5301)",
    "programs": ["bia_tcr", "bia_tcr_awards", "epa_gap", "epa_stag", "epa_tribal_air"]
  }
  ```

  Place this after the `structural_asks` array at the end of the JSON object.

  The programs list connects to BIA programs (bia_tcr, bia_tcr_awards) and EPA Tribal programs (epa_gap, epa_stag, epa_tribal_air) which carry direct trust responsibility implications for environmental protection on Tribal lands.
  </action>
  <verify>
  Run:
  ```bash
  python -c "
  from src.graph.schema import TrustSuperNode, node_to_dict
  t = TrustSuperNode(id='test', name='Test', description='desc', legal_basis='basis')
  d = node_to_dict(t)
  assert d['_type'] == 'TrustSuperNode'
  assert d['id'] == 'test'
  print('PASS: TrustSuperNode class works')

  import json
  gs = json.load(open('data/graph_schema.json'))
  tsn = gs['trust_super_node']
  assert tsn['id'] == 'FEDERAL_TRUST_RESPONSIBILITY'
  assert len(tsn['programs']) == 5
  assert 'bia_tcr' in tsn['programs']
  assert 'epa_tribal_air' in tsn['programs']
  print('PASS: trust_super_node JSON data present')
  "
  ```
  </verify>
  <done>TrustSuperNode dataclass exists in schema.py with id, name, description, legal_basis fields. graph_schema.json contains trust_super_node object with FEDERAL_TRUST_RESPONSIBILITY connecting to 5 BIA/EPA programs. Edge docstring documents ADVANCES and TRUST_OBLIGATION edge types.</done>
</task>

<task type="auto">
  <name>Task 2: Extend GraphBuilder to load Structural Asks and Trust Super-Node</name>
  <files>src/graph/builder.py</files>
  <action>
  Extend `src/graph/builder.py` with two new methods and wire them into the build pipeline:

  **1. Update imports** at the top of builder.py to include TrustSuperNode:
  ```python
  from src.graph.schema import (
      ProgramNode, AuthorityNode, FundingVehicleNode,
      BarrierNode, AdvocacyLeverNode, ObligationNode, TrustSuperNode, Edge,
      node_to_dict, edge_to_dict,
  )
  ```

  **2. Add `_seed_structural_asks` method** to GraphBuilder class (after `_seed_from_schema`):

  Follow the exact same pattern as the existing barriers/authorities seeding in `_seed_from_schema`. The structural asks data is already in graph_schema.json under the `structural_asks` key with 5 entries. Each entry has: id, name, description, target, urgency, mitigates (barrier IDs), programs (program IDs).

  ```python
  def _seed_structural_asks(self, schema: dict) -> None:
      """Load Five Structural Asks as AdvocacyLeverNodes with ADVANCES edges."""
      for ask in schema.get("structural_asks", []):
          node = AdvocacyLeverNode(
              id=ask["id"],
              description=ask["description"],
              target=ask.get("target", ""),
              urgency=ask.get("urgency", ""),
          )
          self.graph.add_node(node)
          # ADVANCES edges: Ask -> Program
          for pid in ask.get("programs", []):
              self.graph.add_edge(Edge(
                  source_id=ask["id"],
                  target_id=pid,
                  edge_type="ADVANCES",
              ))
          # Structural ask mitigates barriers (reuses existing MITIGATED_BY edge type)
          for bar_id in ask.get("mitigates", []):
              self.graph.add_edge(Edge(
                  source_id=ask["id"],
                  target_id=bar_id,
                  edge_type="MITIGATED_BY",
              ))
  ```

  Note: Structural asks reuse `AdvocacyLeverNode` (not a new node type) per RESEARCH.md recommendation. The `ask_` ID prefix distinguishes them from per-program `lever_` nodes. The `name` field from the JSON is used as the `description` field on AdvocacyLeverNode since AdvocacyLeverNode does not have a `name` field -- the `description` already serves this purpose. The `action_verb` field is left empty (not applicable to structural asks).

  **3. Add `_seed_trust_node` method** to GraphBuilder class (after `_seed_structural_asks`):

  ```python
  def _seed_trust_node(self, schema: dict) -> None:
      """Load Trust Super-Node with TRUST_OBLIGATION edges to BIA/EPA programs."""
      trust_data = schema.get("trust_super_node")
      if not trust_data:
          return
      node = TrustSuperNode(
          id=trust_data["id"],
          name=trust_data["name"],
          description=trust_data.get("description", ""),
          legal_basis=trust_data.get("legal_basis", ""),
      )
      self.graph.add_node(node)
      for pid in trust_data.get("programs", []):
          self.graph.add_edge(Edge(
              source_id=trust_data["id"],
              target_id=pid,
              edge_type="TRUST_OBLIGATION",
          ))
  ```

  **4. Wire new methods into `_seed_from_schema`:**

  At the end of the existing `_seed_from_schema` method (after the barriers loop at ~line 237), add calls:

  ```python
      # Structural Asks (Five Structural Asks as AdvocacyLeverNodes with ADVANCES edges)
      self._seed_structural_asks(schema)

      # Trust Super-Node
      self._seed_trust_node(schema)
  ```

  This requires passing the already-loaded `schema` dict to the new methods. The schema is already loaded in `_seed_from_schema` via `json.load()`. Refactor `_seed_from_schema` so the schema variable is accessible -- either pass it as an argument to the new methods (recommended) or call `_seed_structural_asks(schema)` and `_seed_trust_node(schema)` directly inside `_seed_from_schema` after the barriers loop.

  Do NOT modify `_seed_from_programs`, `_enrich_from_items`, or `_add_obligation` methods.
  Do NOT change the `build()` method call order -- the new seeding happens inside `_seed_from_schema`, not as separate top-level calls.
  </action>
  <verify>
  Run an end-to-end graph build verification:
  ```bash
  python -c "
  import json
  from src.graph.builder import GraphBuilder

  # Load programs
  with open('data/program_inventory.json') as f:
      programs = json.load(f)['programs']

  # Build graph with empty scored items (just static seeding)
  builder = GraphBuilder(programs)
  graph = builder.build([])
  graph_data = graph.to_dict()

  # Check structural asks loaded as nodes
  ask_nodes = [n for n_id, n in graph_data['nodes'].items() if n_id.startswith('ask_')]
  assert len(ask_nodes) == 5, f'Expected 5 structural ask nodes, got {len(ask_nodes)}'
  print(f'PASS: {len(ask_nodes)} structural ask nodes')

  # Check ADVANCES edges
  advances_edges = [e for e in graph_data['edges'] if e['type'] == 'ADVANCES']
  assert len(advances_edges) > 0, 'No ADVANCES edges found'
  print(f'PASS: {len(advances_edges)} ADVANCES edges')

  # Check Trust Super-Node
  assert 'FEDERAL_TRUST_RESPONSIBILITY' in graph_data['nodes']
  trust_node = graph_data['nodes']['FEDERAL_TRUST_RESPONSIBILITY']
  assert trust_node['_type'] == 'TrustSuperNode'
  print('PASS: Trust Super-Node present')

  # Check TRUST_OBLIGATION edges
  trust_edges = [e for e in graph_data['edges'] if e['type'] == 'TRUST_OBLIGATION']
  assert len(trust_edges) == 5, f'Expected 5 TRUST_OBLIGATION edges, got {len(trust_edges)}'
  print(f'PASS: {len(trust_edges)} TRUST_OBLIGATION edges')

  # Check total graph health
  summary = graph_data['summary']
  print(f'Total nodes: {summary[\"total_nodes\"]}, edges: {summary[\"total_edges\"]}')
  print(f'Node types: {summary[\"node_types\"]}')
  print('ALL GRAPH CHECKS PASS')
  "
  ```
  </verify>
  <done>GraphBuilder._seed_from_schema loads structural_asks as 5 AdvocacyLeverNodes with ADVANCES edges to their connected programs and MITIGATED_BY edges to their connected barriers. Trust Super-Node (FEDERAL_TRUST_RESPONSIBILITY) loads as TrustSuperNode with 5 TRUST_OBLIGATION edges to BIA/EPA programs. Graph serialization includes both new edge types and TrustSuperNode in node_types.</done>
</task>

</tasks>

<verification>
After both tasks, run the full pipeline to confirm no regressions:

```bash
cd F:\tcr-policy-scanner
python -c "
import json
from src.graph.builder import GraphBuilder

# Load programs
with open('data/program_inventory.json') as f:
    programs = json.load(f)['programs']

# Build graph
builder = GraphBuilder(programs)
graph = builder.build([])
gd = graph.to_dict()

# 1. All 16 programs present
program_nodes = [n for n in gd['nodes'].values() if n['_type'] == 'ProgramNode']
assert len(program_nodes) == 16, f'Expected 16 programs, got {len(program_nodes)}'

# 2. Five Structural Asks
ask_nodes = [n_id for n_id in gd['nodes'] if n_id.startswith('ask_')]
assert len(ask_nodes) == 5

# 3. ADVANCES edges connect asks to programs
advances = [e for e in gd['edges'] if e['type'] == 'ADVANCES']
# 5 asks * avg ~7 programs each = ~30+ edges
assert len(advances) >= 25, f'Expected 25+ ADVANCES edges, got {len(advances)}'

# 4. Trust Super-Node
assert 'FEDERAL_TRUST_RESPONSIBILITY' in gd['nodes']
trust_edges = [e for e in gd['edges'] if e['type'] == 'TRUST_OBLIGATION']
assert len(trust_edges) == 5

# 5. Existing edge types still work
auth_edges = [e for e in gd['edges'] if e['type'] == 'AUTHORIZED_BY']
assert len(auth_edges) > 0, 'No AUTHORIZED_BY edges -- existing seeding broken'

barrier_edges = [e for e in gd['edges'] if e['type'] == 'BLOCKED_BY']
assert len(barrier_edges) > 0, 'No BLOCKED_BY edges -- existing seeding broken'

print(f'Graph: {gd[\"summary\"][\"total_nodes\"]} nodes, {gd[\"summary\"][\"total_edges\"]} edges')
print(f'ADVANCES edges: {len(advances)}')
print(f'TRUST_OBLIGATION edges: {len(trust_edges)}')
print(f'Node types: {gd[\"summary\"][\"node_types\"]}')
print('ALL VERIFICATION CHECKS PASS')
"
```
</verification>

<success_criteria>
1. Graph builder produces 5 AdvocacyLeverNodes for the Five Structural Asks (ask_multi_year, ask_match_waivers, ask_direct_access, ask_consultation, ask_data_sovereignty)
2. ADVANCES edges connect each structural ask to its listed programs (25+ edges total)
3. Structural asks also create MITIGATED_BY edges to their connected barriers
4. FEDERAL_TRUST_RESPONSIBILITY TrustSuperNode exists in the graph
5. 5 TRUST_OBLIGATION edges connect Trust Super-Node to bia_tcr, bia_tcr_awards, epa_gap, epa_stag, epa_tribal_air
6. All existing graph functionality (authorities, barriers, funding vehicles, per-program levers) continues working
7. Graph serialization via to_dict() includes TrustSuperNode in node_types
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-model-graph/02-02-SUMMARY.md`
</output>
