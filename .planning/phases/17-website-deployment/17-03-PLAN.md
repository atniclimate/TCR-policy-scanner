---
phase: 17-website-deployment
plan: 03
type: execute
wave: 2
depends_on: ["17-01", "17-02"]
files_modified:
  - docs/web/js/combobox.js
  - docs/web/js/app.js
autonomous: true

must_haves:
  truths:
    - "Typing a misspelled Tribe name (e.g., 'navjo') finds the correct Tribe (Navajo Nation) via Fuse.js fuzzy search"
    - "Typing an alias (e.g., 'Apsaalooke') finds the correct Tribe (Crow Tribe) via aliases in tribes.json"
    - "Keyboard navigation works: ArrowDown/Up moves through listbox, Enter selects, Escape closes"
    - "Screen reader announces combobox role, option count, and selected option via aria-activedescendant"
    - "State filter dropdown shows all Tribes in the selected state as clickable items"
    - "Selecting a Tribe shows card with download buttons using descriptive filenames"
    - "Data freshness badge shows green/yellow/red based on generated_at timestamp"
    - "Download Both button triggers sequential downloads with 300ms delay"
  artifacts:
    - path: "docs/web/js/combobox.js"
      provides: "Custom ARIA 1.2 combobox with keyboard navigation and Fuse.js integration"
      contains: "TribeCombobox"
    - path: "docs/web/js/app.js"
      provides: "Main application: data loading, Fuse.js init, state filter, card rendering, downloads"
      contains: "Fuse"
  key_links:
    - from: "docs/web/js/combobox.js"
      to: "docs/web/js/app.js"
      via: "TribeCombobox constructor called from app.js with Fuse instance"
      pattern: "new TribeCombobox"
    - from: "docs/web/js/app.js"
      to: "docs/web/data/tribes.json"
      via: "fetch('data/tribes.json') loads Tribe data"
      pattern: "fetch.*tribes\\.json"
    - from: "docs/web/js/app.js"
      to: "docs/web/js/fuse.min.js"
      via: "new Fuse() creates search index from tribes data"
      pattern: "new Fuse"
---

<objective>
Implement the JavaScript logic: a W3C APG-compliant ARIA combobox component powered by Fuse.js, the main application controller with state filtering, card rendering, descriptive download filenames, and data freshness badges.

Purpose: This plan wires the HTML structure (Plan 02) to the data pipeline (Plan 01) via interactive JavaScript. The combobox enables typo-tolerant search across 592 Tribe names + 18,776 aliases. The app controller handles state filtering, card rendering with download buttons, and freshness indicators.

Output: `combobox.js` (reusable ARIA combobox) and `app.js` (application logic).
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/17-website-deployment/17-CONTEXT.md
@.planning/phases/17-website-deployment/17-RESEARCH.md
@.planning/phases/17-website-deployment/17-01-SUMMARY.md
@.planning/phases/17-website-deployment/17-02-SUMMARY.md
@docs/web/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create combobox.js -- W3C APG ARIA combobox component</name>
  <files>docs/web/js/combobox.js</files>
  <action>
Create `docs/web/js/combobox.js` implementing the W3C ARIA Authoring Practices Guide "Editable Combobox with List Autocomplete" pattern.

**Constructor: `TribeCombobox(inputEl, listboxEl, statusEl, fuseInstance)`**
- `inputEl`: The `<input role="combobox">` element
- `listboxEl`: The `<ul role="listbox">` element
- `statusEl`: The `<div role="status">` element for announcing result count
- `fuseInstance`: A configured Fuse.js instance

**Internal state:**
- `this.options = []` -- array of currently rendered `<li>` elements
- `this.activeIndex = -1` -- index of visually focused option (-1 = none)
- `this._lastQuery = ''` -- last search query (for re-search on select)
- `this._lastResults = []` -- cached Fuse.js results for the last query
- `this.onTribeSelected = null` -- callback function set by app.js

**Event handlers to bind in constructor:**
- `input` event on inputEl -> `this.onInput()`
- `keydown` event on inputEl -> `this.onKeyDown(e)`
- `blur` event on inputEl -> `this.onBlur()`
- `click` event on listboxEl -> `this.onOptionClick(e)`

**Method: `onInput()`**
1. Get trimmed value from input
2. If length < 2: close listbox, clear status, return
3. Run `this.fuse.search(query)` and take first 15 results
4. Cache results in `this._lastResults`
5. Call `this.renderOptions(results)`
6. Open listbox
7. Announce result count: `statusEl.textContent = results.length + ' results available'` (or "No results found" if 0)

**Method: `onKeyDown(e)`**
Handle these keys:
- `ArrowDown`: preventDefault. If closed, trigger onInput. If open, moveFocus(1).
- `ArrowUp`: preventDefault. If closed, trigger onInput then moveFocus to last. If open, moveFocus(-1).
- `Enter`: preventDefault. If activeIndex >= 0, selectOption(activeIndex).
- `Escape`: Close listbox. If input has value, clear it on second Escape.

**Method: `moveFocus(delta)`**
1. If no options, return
2. Clear aria-selected on previous active option
3. Calculate new index with wrapping: `(activeIndex + delta + len) % len`
4. Set aria-selected="true" on new option
5. Update `aria-activedescendant` on inputEl to new option's id
6. Call `opt.scrollIntoView({ block: 'nearest' })` to keep visible

**Method: `renderOptions(results)`**
1. Remove all children from listboxEl using `while (listbox.firstChild) listbox.removeChild(listbox.firstChild)`
2. Reset `this.options = []` and `this.activeIndex = -1`
3. For each result:
   - Create `<li role="option" id="opt-{i}" aria-selected="false">`
   - Set textContent to `result.item.name`
   - If result matched on an alias (check `result.matches` for key containing "aliases"), append a secondary line showing "Also known as: {matched alias}"
   - Append a `<span class="option-state">` with `result.item.states.join(', ')`
   - Add to listbox and push to options array
4. Clear `aria-activedescendant` on input

**Method: `selectOption(index)`**
1. Get the corresponding result from `this._lastResults[index]`
2. Set input value to `result.item.name`
3. Close listbox
4. If `this.onTribeSelected` is a function, call it with `result.item`

**Methods: `open()`, `close()`, `isOpen()`**
- open: unhide listbox, set aria-expanded="true"
- close: hide listbox, set aria-expanded="false", reset activeIndex to -1, clear aria-activedescendant
- isOpen: return `!this.listbox.hidden`

**Method: `onBlur()`**
- Delay 200ms (setTimeout) then close. This allows click events on options to register before blur closes the listbox.

**Method: `onOptionClick(e)`**
- Find closest `[role="option"]` from e.target
- Find its index in this.options
- If found, call selectOption(index)

**IMPORTANT implementation notes:**
- Use `var` not `let`/`const` for maximum browser compatibility (no build step)
- Use prototype methods, not class syntax (broader support)
- Use `document.createElement` and `textContent` for all DOM operations (XSS prevention)
- The combobox module should be a self-contained IIFE that exposes `window.TribeCombobox`
- Follow the research code example in 17-RESEARCH.md closely
  </action>
  <verify>
Open browser dev console. After app.js loads:
- Type "nav" in search box -- should show results
- Press ArrowDown -- first option should highlight
- Press Enter -- option should be selected
- Press Escape -- listbox should close
- Check: `document.querySelector('[role="combobox"]').getAttribute('aria-controls')` returns "tribe-listbox"
  </verify>
  <done>
combobox.js implements complete W3C APG ARIA combobox pattern: keyboard navigation (ArrowDown/Up/Enter/Escape), aria-activedescendant focus management, aria-expanded toggle, result count announcement via live region, and click selection. Exposed as window.TribeCombobox.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite app.js -- main application with Fuse.js search, state filter, cards, downloads</name>
  <files>docs/web/js/app.js</files>
  <action>
Rewrite `docs/web/js/app.js` as an IIFE with the following structure:

**Data loading (init):**
1. Fetch `data/tribes.json`
2. Parse JSON, store tribes array and regions array
3. Build Fuse.js search index:
```javascript
var fuse = new Fuse(data.tribes, {
  keys: [
    { name: 'name', weight: 3 },
    { name: 'aliases', weight: 1 },
    { name: 'states', weight: 0.5 }
  ],
  threshold: 0.4,
  ignoreLocation: true,
  includeScore: true,
  includeMatches: true,
  minMatchCharLength: 2,
  shouldSort: true
});
```
4. Initialize TribeCombobox: `var combobox = new TribeCombobox(searchInput, listboxEl, statusEl, fuse)`
5. Set `combobox.onTribeSelected = showCard`
6. Enable search input (remove disabled)
7. Populate state dropdown from data
8. Render regional documents section
9. Hide loading message

**State filter:**
1. Build sorted state list from `new Set(data.tribes.flatMap(t => t.states))`
2. Populate `<select>` with `<option>` for each state
3. On change: if state selected, filter tribes by `t.states.includes(stateCode)`, render results in state-results section. If "All states" selected, hide state-results.
4. Each state result item is a clickable div with Tribe name and state abbreviation
5. Clicking a state result item calls `showCard(tribe)` -- same as search selection

**showCard(tribe):**
1. Set tribe name in h2
2. Set states and ecoregion in detail rows
3. Compute and display freshness badge:
```javascript
function getFreshnessBadge(generatedAt) {
  if (!generatedAt) return { cls: 'badge-unknown', text: 'Unknown', label: 'Data freshness unknown' };
  var days = (Date.now() - new Date(generatedAt).getTime()) / 86400000;
  if (days < 7)  return { cls: 'badge-fresh', text: 'Current', label: 'Data is current (less than 7 days old)' };
  if (days < 30) return { cls: 'badge-aging', text: 'Recent', label: 'Data is recent (less than 30 days old)' };
  return { cls: 'badge-stale', text: 'Needs Update', label: 'Data may need updating (more than 30 days old)' };
}
```
   - Set badge class, text, and aria-label on the freshness badge element
4. Build download buttons using DOM methods (createElement, textContent -- NO innerHTML):
   - Internal Strategy button (green, class `btn-internal`) with descriptive filename
   - Congressional Overview button (blue, class `btn-congressional`) with descriptive filename
   - Download Both button (purple, class `btn-both`)
   - If no documents: disabled span "Documents are being prepared. Check back soon."

**Descriptive download filenames:**
```javascript
function sanitizeFilename(name) {
  return name.replace(/[^a-zA-Z0-9 _-]/g, '').replace(/\s+/g, '_');
}
```
- Internal: `{SafeName}_Internal_Strategy.docx`
- Congressional: `{SafeName}_Congressional_Overview.docx`
- Use the `download` attribute on `<a>` tags

**Download Both:**
```javascript
function downloadBoth(docAPath, docBPath, tribeName) {
  var safeName = sanitizeFilename(tribeName);
  var a1 = document.createElement('a');
  a1.href = 'tribes/' + docAPath;
  a1.download = safeName + '_Internal_Strategy.docx';
  document.body.appendChild(a1);
  a1.click();
  document.body.removeChild(a1);
  setTimeout(function() {
    var a2 = document.createElement('a');
    a2.href = 'tribes/' + docBPath;
    a2.download = safeName + '_Congressional_Overview.docx';
    document.body.appendChild(a2);
    a2.click();
    document.body.removeChild(a2);
  }, 300);
}
```

**Regional documents rendering:**
- Keep existing pattern from current app.js
- Each region card shows: region name, states, Internal Strategy button, Congressional Overview button
- Use descriptive filenames for regional downloads too: `{RegionName}_Internal_Strategy.docx`, `{RegionName}_Congressional_Overview.docx`

**Card visibility animation:**
- When showing card: set `data-visible` attribute (CSS handles opacity transition)
- When hiding: remove `data-visible` attribute

**Error handling:**
- fetch failure: show error message, hide loading
- Empty tribes array: show "No Tribe data available" message

**IMPORTANT implementation notes:**
- Use `var` for declarations (no let/const -- broader browser compat without build step)
- Use `"use strict"` inside the IIFE
- All DOM manipulation via `createElement`/`textContent` -- zero innerHTML
- Keep the escapeText helper for aria-labels
- Remove ALL Awesomplete references (no `awesomplete-selectcomplete` event listener)
- Ensure app.js is a standalone IIFE that runs on DOMContentLoaded
  </action>
  <verify>
Open `docs/web/index.html` in browser with a local server.
Test:
1. Type "nav" -- Navajo Nation appears in dropdown
2. Type "apsaalooke" -- Crow Tribe appears (alias match)
3. ArrowDown/Up to navigate, Enter to select
4. Escape to clear
5. Select a state from dropdown -- browse list appears
6. Click a tribe in browse list -- card appears
7. Check freshness badge appears on card
8. Click download buttons -- verify descriptive filenames in download dialog
9. Test at 375px width -- no horizontal scroll, buttons stack vertically
  </verify>
  <done>
app.js implements: Fuse.js initialization with weighted multi-key search (name weight 3, aliases weight 1, states weight 0.5), TribeCombobox integration, state filter dropdown with browse results, showCard with freshness badges and descriptive download filenames, Download Both with sequential 300ms-delayed downloads, and regional document rendering. Zero Awesomplete references.
  </done>
</task>

</tasks>

<verification>
1. Search for "navjo" (typo) returns Navajo Nation in top results
2. Search for "apsaalooke" returns Crow Tribe via alias matching
3. Keyboard: ArrowDown/Up navigates, Enter selects, Escape closes
4. Screen reader: combobox role announced, option count announced, aria-activedescendant updates
5. State filter: selecting a state shows all Tribes in that state
6. Freshness badge: green for <7 days, yellow for <30 days, red for >30 days
7. Download filenames: `Navajo_Nation_Internal_Strategy.docx` format
8. Download Both: two files downloaded sequentially
9. Mobile 375px: no horizontal scroll, 44px touch targets
</verification>

<success_criteria>
- Fuzzy search finds Tribes by name, alias, and state with typo tolerance
- ARIA combobox fully keyboard navigable (ArrowDown/Up/Enter/Escape)
- State filter provides alternative browse-by-state discovery path
- Freshness badges display correct color and text based on data age
- Download buttons use descriptive human-readable filenames
- Download Both triggers two sequential downloads
- Zero Awesomplete code or event listeners remain
- All DOM manipulation uses createElement/textContent (no innerHTML)
</success_criteria>

<output>
After completion, create `.planning/phases/17-website-deployment/17-03-SUMMARY.md`
</output>
