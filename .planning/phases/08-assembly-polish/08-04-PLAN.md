---
phase: 08-assembly-polish
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/packets/change_tracker.py
  - src/packets/docx_engine.py
  - src/packets/docx_sections.py
  - src/packets/orchestrator.py
  - tests/test_change_tracking.py
autonomous: true

must_haves:
  truths:
    - "PacketChangeTracker stores per-Tribe state as JSON in data/packet_state/{tribe_id}.json"
    - "First generation: no previous state, no changes, no 'Since Last Packet' section"
    - "Second generation detects CI status changes, new awards, award total changes, advocacy goal shifts"
    - "render_change_tracking() groups changes by type with human-readable descriptions"
    - "Empty changes list = section NOT rendered (omitted entirely)"
    - "Corrupt state file treated as first generation (graceful degradation)"
    - "Atomic write pattern for state persistence (tmp + os.replace())"
    - "State snapshot schema includes: tribe_id, generated_at, program_states, total_awards, total_obligation, top_hazards"
    - "Path traversal protection: Path(tribe_id).name + reject '.' and '..'"
    - "JSON cache size limit: 10MB cap via stat().st_size check before json.load()"
    - "Single-writer-per-tribe_id concurrency assumption documented in docstrings"
    - "encoding='utf-8' on all file I/O"
  artifacts:
    - path: "src/packets/change_tracker.py"
      provides: "PacketChangeTracker class with load_previous, compute_current, diff, save_current"
      min_lines: 120
    - path: "src/packets/docx_sections.py"
      provides: "render_change_tracking() function added to existing section renderers"
      contains: "render_change_tracking"
    - path: "src/packets/orchestrator.py"
      provides: "Change tracker wired into generate_packet_from_context()"
      contains: "PacketChangeTracker"
    - path: "tests/test_change_tracking.py"
      provides: "Tests for change tracking: first gen, diffs, state persistence, corruption handling"
      min_lines: 120
  key_links:
    - from: "src/packets/orchestrator.py"
      to: "src/packets/change_tracker.py"
      via: "generate_packet_from_context() uses PacketChangeTracker to load/diff/save state"
      pattern: "PacketChangeTracker"
    - from: "src/packets/change_tracker.py"
      to: "src/packets/context.py"
      via: "compute_current() reads from TribePacketContext fields"
      pattern: "TribePacketContext"
    - from: "src/packets/docx_engine.py"
      to: "src/packets/docx_sections.py"
      via: "generate() calls render_change_tracking() when changes list is non-empty"
      pattern: "render_change_tracking"
---

<objective>
Add per-Tribe change tracking that detects what shifted between packet generations and renders a "Since Last Packet" section in the DOCX when changes exist.

Purpose: OPS-03 (change tracking) enables congressional staff to quickly see what changed since the last packet was generated -- CI status shifts, new awards, funding total changes, and advocacy goal updates. This is critical for ongoing relationship management: staff can scan the change section instead of re-reading the entire packet.
Output: PacketChangeTracker module, render_change_tracking section renderer, orchestrator integration, and comprehensive tests.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-assembly-polish/08-CONTEXT.md
@.planning/phases/08-assembly-polish/08-MASTER-PROMPT.md
@.planning/phases/08-assembly-polish/08-01-SUMMARY.md

@src/packets/context.py
@src/packets/orchestrator.py
@src/packets/docx_engine.py
@src/packets/docx_sections.py
@src/packets/docx_styles.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/packets/change_tracker.py</name>
  <files>src/packets/change_tracker.py</files>
  <action>
Create `src/packets/change_tracker.py` with the PacketChangeTracker class.

**Imports:**
- `json`, `logging`, `os`, `tempfile` from stdlib
- `Path` from pathlib
- `datetime`, `timezone` from datetime
- `TribePacketContext` from `src.packets.context`

**Constants:**
- `MAX_STATE_FILE_SIZE = 10 * 1024 * 1024` (10MB)
- `logger = logging.getLogger("tcr_scanner.packets.change_tracker")`

**Class PacketChangeTracker:**

```python
class PacketChangeTracker:
    """Tracks per-Tribe packet state for change detection.

    State stored as JSON: {state_dir}/{tribe_id}.json
    Single-writer-per-tribe_id assumed (no concurrent generation for same Tribe).

    Security:
    - Path traversal protection via Path(tribe_id).name
    - 10MB size limit on state files
    - Atomic write via tmp + os.replace()
    """

    def __init__(self, state_dir: Path = Path("data/packet_state")):
        self.state_dir = state_dir

    def _safe_path(self, tribe_id: str) -> Path:
        """Build safe file path with traversal protection."""
        safe_id = Path(tribe_id).name
        if safe_id in (".", "..") or not safe_id:
            raise ValueError(f"Invalid tribe_id: {tribe_id}")
        return self.state_dir / f"{safe_id}.json"

    def load_previous(self, tribe_id: str) -> dict | None:
        """Load previous state. Returns None if first generation or corrupt."""
        path = self._safe_path(tribe_id)
        if not path.exists():
            return None
        try:
            file_size = path.stat().st_size
            if file_size > MAX_STATE_FILE_SIZE:
                logger.warning("State file too large (%d bytes): %s", file_size, path)
                return None
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict) or "tribe_id" not in data:
                logger.warning("Invalid state file schema: %s", path)
                return None
            return data
        except (json.JSONDecodeError, OSError, ValueError) as exc:
            logger.warning("Corrupt state file %s, treating as first generation: %s", path, exc)
            return None

    def compute_current(self, context: TribePacketContext, programs: dict) -> dict:
        """Snapshot current state from context and program data.

        Args:
            context: TribePacketContext with awards, hazard data, etc.
            programs: Dict of program_id -> program dict (with ci_status, etc.)

        Returns:
            State snapshot dict matching the persisted schema.
        """
        program_states = {}
        for prog_id, prog in programs.items():
            # Compute per-program award total from context awards
            prog_award_total = sum(
                a.get("obligation", 0) or 0
                for a in (context.awards or [])
                if a.get("program_id") == prog_id
            )
            program_states[prog_id] = {
                "ci_status": prog.get("ci_status", "UNKNOWN"),
                "advocacy_goal": prog.get("advocacy_goal", ""),
                "award_total": prog_award_total,
            }

        total_obligation = sum(
            a.get("obligation", 0) or 0
            for a in (context.awards or [])
        )

        # Extract top hazards
        top_hazards = []
        hazard_profile = context.hazard_profile or {}
        fema_nri = hazard_profile.get("fema_nri", {})
        for hazard in fema_nri.get("top_hazards", [])[:5]:
            top_hazards.append(hazard.get("type", "Unknown"))

        return {
            "tribe_id": context.tribe_id,
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "program_states": program_states,
            "total_awards": len(context.awards or []),
            "total_obligation": total_obligation,
            "top_hazards": top_hazards,
        }

    def diff(self, previous: dict, current: dict) -> list[dict]:
        """Compute changes between previous and current state.

        Returns:
            List of change dicts, each with keys: type, description, and
            type-specific fields. Empty list means no changes detected.

        Change types:
        - ci_status_change: Program CI status shifted
        - new_award: New awards appeared since last generation
        - award_total_change: Total obligation amount changed
        - advocacy_goal_shift: Program advocacy goal changed
        - new_threat: New hazard appeared in top hazards
        """
        changes = []

        prev_programs = previous.get("program_states", {})
        curr_programs = current.get("program_states", {})

        # CI status changes
        for prog_id, curr_state in curr_programs.items():
            prev_state = prev_programs.get(prog_id, {})
            old_ci = prev_state.get("ci_status")
            new_ci = curr_state.get("ci_status")
            if old_ci and new_ci and old_ci != new_ci:
                changes.append({
                    "type": "ci_status_change",
                    "program_id": prog_id,
                    "old_status": old_ci,
                    "new_status": new_ci,
                    "description": f"{prog_id}: CI status changed from {old_ci} to {new_ci}",
                })

        # Advocacy goal shifts
        for prog_id, curr_state in curr_programs.items():
            prev_state = prev_programs.get(prog_id, {})
            old_goal = prev_state.get("advocacy_goal")
            new_goal = curr_state.get("advocacy_goal")
            if old_goal and new_goal and old_goal != new_goal:
                changes.append({
                    "type": "advocacy_goal_shift",
                    "program_id": prog_id,
                    "old_goal": old_goal,
                    "new_goal": new_goal,
                    "description": f"{prog_id}: advocacy goal shifted from {old_goal} to {new_goal}",
                })

        # Award total changes
        prev_total = previous.get("total_obligation", 0)
        curr_total = current.get("total_obligation", 0)
        if prev_total != curr_total:
            diff_amount = curr_total - prev_total
            direction = "increased" if diff_amount > 0 else "decreased"
            changes.append({
                "type": "award_total_change",
                "old_total": prev_total,
                "new_total": curr_total,
                "diff": diff_amount,
                "description": f"Total obligation {direction} by ${abs(diff_amount):,.0f} (${prev_total:,.0f} -> ${curr_total:,.0f})",
            })

        # New awards
        prev_count = previous.get("total_awards", 0)
        curr_count = current.get("total_awards", 0)
        if curr_count > prev_count:
            new_count = curr_count - prev_count
            changes.append({
                "type": "new_award",
                "new_count": new_count,
                "description": f"{new_count} new award(s) since last packet",
            })

        # New threats
        prev_hazards = set(previous.get("top_hazards", []))
        curr_hazards = set(current.get("top_hazards", []))
        new_hazards = curr_hazards - prev_hazards
        for hazard in sorted(new_hazards):
            changes.append({
                "type": "new_threat",
                "hazard": hazard,
                "description": f"New hazard identified: {hazard}",
            })

        return changes

    def save_current(self, tribe_id: str, state: dict) -> None:
        """Persist current state with atomic write.

        Uses tmp file + os.replace() pattern to prevent corruption.
        Creates state_dir if it does not exist.
        """
        path = self._safe_path(tribe_id)
        self.state_dir.mkdir(parents=True, exist_ok=True)

        tmp_fd = None
        tmp_path = None
        try:
            tmp_fd, tmp_path = tempfile.mkstemp(
                dir=str(self.state_dir),
                suffix=".tmp",
                prefix=f"{Path(tribe_id).name}_",
            )
            with os.fdopen(tmp_fd, "w", encoding="utf-8") as f:
                tmp_fd = None  # os.fdopen takes ownership
                json.dump(state, f, indent=2, ensure_ascii=False)
            os.replace(tmp_path, str(path))
            tmp_path = None  # successful, no cleanup needed
        except Exception:
            if tmp_fd is not None:
                os.close(tmp_fd)
            if tmp_path is not None:
                try:
                    os.unlink(tmp_path)
                except OSError:
                    pass
            raise
```

**Critical notes:**
- `_safe_path()` uses `Path(tribe_id).name` to strip directory components (path traversal protection)
- `load_previous()` returns None for any corruption (graceful degradation to first-generation behavior)
- `save_current()` uses the atomic write pattern from Phase 7: tmp file + os.replace() with cleanup on exception
- `compute_current()` reads directly from TribePacketContext fields (no external I/O)
- 10MB size limit checked via `stat().st_size` before `json.load()` (prevents memory bomb)
- All file I/O uses `encoding="utf-8"`
- `datetime.now(timezone.utc)` not `datetime.utcnow()`
  </action>
  <verify>
Run: `python -c "from src.packets.change_tracker import PacketChangeTracker"` -- import works
  </verify>
  <done>PacketChangeTracker handles state loading, current snapshot, diffing, and atomic persistence with security protections.</done>
</task>

<task type="auto">
  <name>Task 2: Add render_change_tracking() to docx_sections.py</name>
  <files>src/packets/docx_sections.py</files>
  <action>
Add `render_change_tracking()` function to the existing `src/packets/docx_sections.py` file.

**Add at the end of the file (after existing render functions):**

```python
def render_change_tracking(document, changes: list[dict],
                           previous_date: str, style_manager) -> None:
    """Render 'Since Last Packet' section showing changes between generations.

    If changes list is empty, this function returns immediately and renders
    nothing (section is omitted entirely from the document).

    Args:
        document: python-docx Document instance.
        changes: List of change dicts from PacketChangeTracker.diff().
        previous_date: ISO date string of previous generation.
        style_manager: StyleManager instance for formatting.
    """
    if not changes:
        return

    # Section header
    date_display = previous_date[:10] if previous_date else "unknown"
    document.add_heading(f"Since Last Packet (generated {date_display})", level=2)

    # Group changes by type
    type_labels = {
        "ci_status_change": "Confidence Index Changes",
        "new_award": "New Awards",
        "award_total_change": "Funding Changes",
        "advocacy_goal_shift": "Advocacy Position Shifts",
        "new_threat": "New Hazard Threats",
    }

    # Collect by type, preserving order of first occurrence
    grouped = {}
    for change in changes:
        ctype = change.get("type", "other")
        if ctype not in grouped:
            grouped[ctype] = []
        grouped[ctype].append(change)

    # Render each group
    for ctype, group in grouped.items():
        label = type_labels.get(ctype, ctype.replace("_", " ").title())
        p = document.add_paragraph()
        run = p.add_run(label)
        run.bold = True

        for change in group:
            description = change.get("description", str(change))
            document.add_paragraph(description, style="List Bullet")

    # Summary count
    summary = document.add_paragraph()
    run = summary.add_run(f"{len(changes)} change(s) detected since last generation.")
    run.italic = True
```

**Critical notes:**
- Empty changes list = immediate return, no section rendered (requirement: omit entirely)
- previous_date is sliced to date portion only ([:10]) for display
- Changes grouped by type with human-readable section labels
- Uses List Bullet style for individual changes (standard python-docx style)
- Does NOT add a page break (caller in DocxEngine.generate() handles page breaks)
  </action>
  <verify>
Run: `python -c "from src.packets.docx_sections import render_change_tracking"` -- import works
  </verify>
  <done>render_change_tracking() renders grouped change descriptions. Empty changes list produces no output.</done>
</task>

<task type="auto">
  <name>Task 3: Wire change tracker into orchestrator</name>
  <files>src/packets/orchestrator.py, src/packets/docx_engine.py</files>
  <action>
**Update `src/packets/orchestrator.py`** -- add change tracker to generate_packet_from_context():

Add import at top of file:
```python
from src.packets.change_tracker import PacketChangeTracker
```

In `generate_packet_from_context()` (at line 429), add change tracking logic before the DocxEngine.generate() call:

```python
# Change tracking (OPS-03)
state_dir = Path(self.config.get("packets", {}).get("state_dir", "data/packet_state"))
tracker = PacketChangeTracker(state_dir=state_dir)
previous_state = tracker.load_previous(context.tribe_id)
current_state = tracker.compute_current(context, self.programs)

changes = []
previous_date = None
if previous_state is not None:
    changes = tracker.diff(previous_state, current_state)
    previous_date = previous_state.get("generated_at")
```

Pass `changes` and `previous_date` to DocxEngine.generate():
```python
path = engine.generate(
    context, relevant, economic_summary, structural_asks,
    omitted, changes=changes, previous_date=previous_date
)
```

After successful generation, save current state:
```python
tracker.save_current(context.tribe_id, current_state)
```

**Verify `src/packets/docx_engine.py`** -- DocxEngine.generate() signature:

Plan 08-01 already added `changes=None` and `previous_date=None` parameters to generate(). Verify the render_change_tracking() call is present and conditional:

```python
# 8. Change tracking (OPS-03, optional)
if changes:
    document.add_page_break()
    render_change_tracking(document, changes, previous_date, style_manager)
```

If this call is not yet present in generate(), add it between the structural asks section and the appendix section.

Also verify `render_change_tracking` is in the imports of docx_engine.py:
```python
from src.packets.docx_sections import (
    render_cover_page, render_table_of_contents, render_appendix,
    render_executive_summary, render_delegation_section,
    render_hazard_summary, render_structural_asks_section,
    render_change_tracking,
)
```

**Critical notes:**
- Change tracker state is saved AFTER successful document generation (not before)
- If generate() raises, state is NOT updated (correct behavior: retry will see same previous state)
- state_dir is configurable via config packets.state_dir (defaults to data/packet_state)
- First generation: previous_state is None -> changes=[] -> render_change_tracking() skips section
  </action>
  <verify>
Run: `python -c "from src.packets.orchestrator import PacketOrchestrator"` -- import works with change tracker
  </verify>
  <done>Change tracker wired into generate_packet_from_context(). State saved after successful generation. First-gen produces no change section.</done>
</task>

<task type="auto">
  <name>Task 4: Create tests/test_change_tracking.py</name>
  <files>tests/test_change_tracking.py</files>
  <action>
Create `tests/test_change_tracking.py` with comprehensive change tracking tests.

**Fixtures:**
- `state_dir(tmp_path)`: Returns tmp_path / "packet_state", creates directory.
- `tracker(state_dir)`: PacketChangeTracker(state_dir=state_dir).
- `mock_context()`: Minimal TribePacketContext with tribe_id="epa_001", awards=[{"program_id": "bia_tcr", "obligation": 500000}], hazard_profile={"fema_nri": {"top_hazards": [{"type": "Wildfire"}]}}.
- `mock_programs()`: Dict with "bia_tcr": {"ci_status": "STABLE", "advocacy_goal": "PROTECT"}.
- `previous_state()`: Dict matching state schema with ci_status="AT_RISK" for bia_tcr.

**Tests:**

1. **test_first_generation_no_previous**: load_previous() returns None for new tribe_id.

2. **test_ci_status_change_detected**: Create previous state with ci_status="STABLE". Create current state with ci_status="AT_RISK". Verify diff() returns change with type="ci_status_change".

3. **test_award_total_change_detected**: Create previous with total_obligation=100000. Create current with total_obligation=600000. Verify diff() returns change with type="award_total_change".

4. **test_advocacy_goal_shift_detected**: Create previous with advocacy_goal="PROTECT". Create current with advocacy_goal="DEFEND". Verify diff() returns change with type="advocacy_goal_shift".

5. **test_new_threat_detected**: Create previous with top_hazards=["Wildfire"]. Create current with top_hazards=["Wildfire", "Flooding"]. Verify diff() returns change with type="new_threat" for "Flooding".

6. **test_no_changes_empty_list**: Create identical previous and current states. Verify diff() returns empty list.

7. **test_state_file_written_correctly**: Call save_current(). Verify file exists at expected path. Read file and verify JSON matches state schema (tribe_id, generated_at, program_states present).

8. **test_state_roundtrip**: save_current() then load_previous(). Verify loaded state matches saved state.

9. **test_corrupt_state_file_handled**: Write invalid JSON to state file. Verify load_previous() returns None (graceful degradation). Verify no exception raised.

10. **test_oversized_state_file_handled**: Write 11MB file to state path. Verify load_previous() returns None. Verify warning logged.

11. **test_path_traversal_rejected**: Verify _safe_path("../../etc/passwd") raises ValueError or produces safe filename. Verify _safe_path("..") raises ValueError.

12. **test_atomic_write_cleanup**: Mock os.replace to raise. Verify tmp file is cleaned up (no orphaned .tmp files in state_dir).

13. **test_render_change_tracking_with_changes**: Create Document, call render_change_tracking() with 2 changes. Verify document has "Since Last Packet" heading. Verify change descriptions appear in paragraphs.

14. **test_render_change_tracking_empty_changes**: Create Document, call render_change_tracking() with empty list. Verify no new paragraphs added (section omitted).

15. **test_new_awards_detected**: Create previous with total_awards=3. Create current with total_awards=5. Verify diff() returns change with type="new_award", new_count=2.

**Critical test patterns:**
- Use tmp_path for state_dir (no real filesystem pollution)
- Use `from docx import Document` for render_change_tracking tests
- Mock TribePacketContext with minimal fields (tribe_id, awards, hazard_profile)
- Do NOT modify any existing test files

Run full suite at the end: `python -m pytest tests/ --tb=short`
  </action>
  <verify>
Run: `python -m pytest tests/test_change_tracking.py -v --tb=short` -- all new tests pass
Run: `python -m pytest tests/ --tb=short` -- full suite passes with no regressions (214+ existing + new)
  </verify>
  <done>Change tracking tests pass. First-gen, diff detection, state persistence, corruption handling, atomic write, path traversal, and render tests all verified.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.packets.change_tracker import PacketChangeTracker"` -- import works
2. `python -c "from src.packets.docx_sections import render_change_tracking"` -- import works
3. `python -m pytest tests/test_change_tracking.py -v` -- all new tests pass
4. `python -m pytest tests/ --tb=short` -- full suite passes (214 existing + new change tracking tests)
5. Verify state file written to data/packet_state/{tribe_id}.json on first generation
6. Verify second generation with changed CI status produces "Since Last Packet" section
7. Verify corrupt state file does not crash (treated as first generation)
</verification>

<success_criteria>
- PacketChangeTracker.load_previous() returns None for first generation
- PacketChangeTracker.diff() detects CI status changes, award total changes, advocacy goal shifts, and new threats
- render_change_tracking() renders grouped changes with human-readable descriptions
- Empty changes list results in section being omitted entirely
- Corrupt or oversized state files are handled gracefully (treated as first generation)
- Atomic write pattern prevents state file corruption (tmp + os.replace())
- Path traversal protection rejects malicious tribe_id values
- State saved only after successful DOCX generation
- All 214+ existing tests still pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-assembly-polish/08-04-SUMMARY.md`
</output>
