---
phase: 08-assembly-polish
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/packets/orchestrator.py
  - src/main.py
  - tests/test_batch_generation.py
autonomous: true

must_haves:
  truths:
    - "run_all_tribes() calls generate_packet_from_context() for each Tribe and returns dict with success/error counts"
    - "GC runs every 25 Tribes (gc.collect())"
    - "Progress reporting shows [N/total] with elapsed time"
    - "Per-Tribe errors do not halt batch (error isolation with try/except per Tribe)"
    - "Strategic overview generated after all Tribes via generate_strategic_overview()"
    - "Output dir structure: outputs/packets/tribes/*.docx"
    - "Return dict: {success, errors, total, duration_s}"
    - "Existing run_single_tribe() produces full DOC-05 document after 08-01 changes (OPS-02 verification)"
    - "All 214+ existing tests still pass"
    - "Error list for failed Tribes is capped at 10 in printed output"
  artifacts:
    - path: "src/packets/orchestrator.py"
      provides: "run_all_tribes() updated with DOCX generation, GC, progress, error isolation"
      contains: "generate_packet_from_context"
    - path: "tests/test_batch_generation.py"
      provides: "Tests for batch and ad-hoc CLI generation modes"
      min_lines: 80
  key_links:
    - from: "src/packets/orchestrator.py"
      to: "src/packets/orchestrator.py"
      via: "run_all_tribes() calls generate_packet_from_context() for each Tribe"
      pattern: "generate_packet_from_context"
    - from: "src/packets/orchestrator.py"
      to: "src/packets/strategic_overview.py"
      via: "run_all_tribes() calls generate_strategic_overview() after batch"
      pattern: "generate_strategic_overview"
    - from: "src/main.py"
      to: "src/packets/orchestrator.py"
      via: "CLI --all-tribes routes to orch.run_all_tribes() at line 326"
      pattern: "run_all_tribes"
---

<objective>
Wire run_all_tribes() to full DOCX generation with memory management, progress reporting, error isolation, and strategic overview generation. Verify ad-hoc single-Tribe generation (OPS-02) produces the complete DOC-05 document.

Purpose: OPS-01 (batch generation for all 592 Tribes) and OPS-02 (ad-hoc single-Tribe generation) enable the CLI to produce complete advocacy packets. After this plan, `python -m src.main --prep-packets --all-tribes` generates 592 per-Tribe DOCX packets plus the strategic overview, and `python -m src.main --prep-packets --tribe "Cherokee Nation"` generates a single complete packet.
Output: Updated orchestrator with batch generation, tests covering batch and ad-hoc modes.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-assembly-polish/08-CONTEXT.md
@.planning/phases/08-assembly-polish/08-MASTER-PROMPT.md
@.planning/phases/08-assembly-polish/08-01-SUMMARY.md
@.planning/phases/08-assembly-polish/08-02-SUMMARY.md

@src/packets/orchestrator.py
@src/packets/docx_engine.py
@src/packets/strategic_overview.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update run_all_tribes() in orchestrator.py</name>
  <files>src/packets/orchestrator.py</files>
  <action>
Update `PacketOrchestrator.run_all_tribes()` (currently at lines 128-157) to perform full DOCX generation instead of context-only builds.

**Change return type** from `None` to `dict`.

**New implementation:**

```python
def run_all_tribes(self) -> dict:
    """Generate DOCX packets for all Tribes + strategic overview.

    Returns:
        dict with keys: success, errors, total, duration_s
    """
    import gc
    import time

    all_tribes = self.registry.get_all()
    total = len(all_tribes)
    start = time.monotonic()
    success_count = 0
    error_count = 0
    error_tribes = []

    for i, tribe in enumerate(all_tribes, 1):
        elapsed = time.monotonic() - start
        print(f"[{i}/{total}] {tribe['name']}...", end="", flush=True)
        try:
            context = self._build_context(tribe)
            self.generate_packet_from_context(context, tribe)
            print(f" OK ({elapsed:.0f}s)")
            success_count += 1
        except Exception as exc:
            print(f" ERROR: {exc}")
            logger.error("Failed: %s: %s", tribe["name"], exc)
            error_count += 1
            error_tribes.append(tribe["name"])
        finally:
            if i % 25 == 0:
                gc.collect()

    # Strategic overview
    print("\nGenerating Strategic Overview...", end="", flush=True)
    try:
        overview_path = self.generate_strategic_overview()
        print(f" OK ({overview_path})")
    except Exception as exc:
        print(f" ERROR: {exc}")
        logger.error("Strategic overview failed: %s", exc)

    duration = time.monotonic() - start
    print(f"\n--- Batch Complete ---")
    print(f"Total: {total} | Success: {success_count} | Errors: {error_count}")
    print(f"Duration: {duration:.0f}s")
    if error_tribes:
        print(f"Failed: {', '.join(error_tribes[:10])}")
        if len(error_tribes) > 10:
            print(f"  ... and {len(error_tribes) - 10} more")

    return {
        "success": success_count,
        "errors": error_count,
        "total": total,
        "duration_s": duration,
    }
```

**Key implementation details:**
- `gc.collect()` every 25 Tribes prevents memory buildup across 592 Tribes (each DOCX holds document objects)
- `time.monotonic()` for elapsed time (immune to system clock adjustments)
- Per-Tribe try/except ensures one failure does not halt the entire batch
- Error list capped at 10 in printed output to avoid flooding the console
- Strategic overview generation after all Tribes (calls generate_strategic_overview() from Plan 08-02)
- Return dict enables programmatic checking (tests, CI)

**Do NOT change:**
- run_single_tribe() (already calls generate_packet_from_context() -- OPS-02 works after 08-01)
- generate_packet_from_context() signature or behavior
- Any imports not needed for gc/time (already standard library)
  </action>
  <verify>
Run: `python -c "from src.packets.orchestrator import PacketOrchestrator"` -- import works
  </verify>
  <done>run_all_tribes() generates DOCX for each Tribe with GC, progress, error isolation, and strategic overview. Returns dict with counts.</done>
</task>

<task type="auto">
  <name>Task 2: Create tests/test_batch_generation.py</name>
  <files>tests/test_batch_generation.py</files>
  <action>
Create `tests/test_batch_generation.py` with tests for batch and ad-hoc generation modes.

**Fixtures (shared mock data):**
- `batch_config(tmp_path)`: Minimal config with 3 mock Tribes in registry, mock program inventory (2 programs), mock ecoregion config, mock congressional cache, output dir in tmp_path. Creates all required data files in tmp_path.
- `mock_orchestrator(batch_config)`: PacketOrchestrator instance with mocked external dependencies (API calls, file I/O outside tmp_path).

**Tests:**

1. **test_batch_generates_docx_per_tribe**: Run run_all_tribes() with 3 mock Tribes. Verify 3 .docx files exist in output directory.

2. **test_batch_error_isolation**: Mock generate_packet_from_context() to raise for the second Tribe only. Verify first and third Tribes still succeed. Verify return dict shows errors=1, success=2.

3. **test_batch_gc_called**: Mock gc.collect(). Run batch with 30 mock Tribes (or patch the list to have 30 entries). Verify gc.collect() was called at least once (at Tribe 25).

4. **test_batch_progress_format**: Capture stdout during batch run. Verify output contains "[1/3]" and "[3/3]" format strings.

5. **test_batch_return_dict**: Run batch with 3 Tribes. Verify return dict has keys: success, errors, total, duration_s. Verify total == 3. Verify duration_s > 0.

6. **test_batch_strategic_overview_called**: Mock generate_strategic_overview(). Run batch. Verify generate_strategic_overview() was called exactly once.

7. **test_single_tribe_generates_full_document**: (OPS-02 verification) Run run_single_tribe() with one mock Tribe. Verify .docx file exists and can be re-read by python-docx Document().

**Critical test patterns:**
- Use `unittest.mock.patch` for gc.collect, generate_packet_from_context, generate_strategic_overview
- Use `capsys` or `io.StringIO` for stdout capture
- Use `tmp_path` for all file output (no real filesystem pollution)
- Reuse mock data patterns from tests/test_docx_integration.py
- Do NOT modify any existing test files

Run full suite at the end: `python -m pytest tests/ --tb=short`
  </action>
  <verify>
Run: `python -m pytest tests/test_batch_generation.py -v --tb=short` -- all new tests pass
Run: `python -m pytest tests/ --tb=short` -- full suite passes with no regressions (214+ existing + 6-7 new)
  </verify>
  <done>Batch generation tests pass. Error isolation verified. GC verified. Progress format verified. OPS-02 single-Tribe verified. All existing tests still pass.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.packets.orchestrator import PacketOrchestrator"` -- import works
2. `python -m pytest tests/test_batch_generation.py -v` -- all new tests pass
3. `python -m pytest tests/ --tb=short` -- full suite passes (214 existing + new batch tests)
4. Verify run_all_tribes() return dict contains success, errors, total, duration_s keys
5. Verify gc.collect() is called at Tribe 25, 50, etc.
6. Verify error in one Tribe does not stop batch
</verification>

<success_criteria>
- run_all_tribes() generates DOCX packets for all Tribes with progress reporting
- GC runs every 25 Tribes to manage memory across 592-Tribe batch
- Per-Tribe errors are isolated (batch continues on failure)
- Strategic overview generated after all individual Tribe packets
- Return dict provides success/error/total/duration_s for programmatic use
- run_single_tribe() produces complete DOC-05 document (OPS-02 verified)
- All 214+ existing tests still pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-assembly-polish/08-03-SUMMARY.md`
</output>
