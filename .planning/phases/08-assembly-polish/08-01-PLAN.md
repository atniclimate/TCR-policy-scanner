---
phase: 08-assembly-polish
plan: 01
type: execute
wave: 1
depends_on: ["07-04"]
files_modified:
  - src/packets/docx_sections.py
  - src/packets/docx_engine.py
  - tests/test_doc_assembly.py
autonomous: true

must_haves:
  truths:
    - "4 new section renderers added: render_executive_summary, render_delegation_section, render_hazard_summary, render_structural_asks_section"
    - "DocxEngine.generate() produces document with 8+ sections in correct order: cover -> TOC -> exec summary -> delegation -> Hot Sheets -> hazard -> structural asks -> appendix"
    - "Executive summary contains Tribe name and at least 1 program reference"
    - "Delegation section lists senators and reps in tabular format"
    - "Hazard summary renders top hazards from FEMA NRI data"
    - "Structural asks section includes 5 asks"
    - "Zero-award/zero-hazard Tribe produces valid DOCX with graceful empty sections"
    - "All 214 existing tests still pass"
  artifacts:
    - path: "src/packets/docx_sections.py"
      provides: "render_executive_summary, render_delegation_section, render_hazard_summary, render_structural_asks_section (extends existing file with 3 renderers)"
      min_lines: 400
    - path: "src/packets/docx_engine.py"
      provides: "DocxEngine.generate() updated with new section calls + optional changes/previous_date params"
      min_lines: 160
    - path: "tests/test_doc_assembly.py"
      provides: "10+ tests for full document assembly with all new sections"
      min_lines: 250
  key_links:
    - from: "src/packets/docx_engine.py"
      to: "src/packets/docx_sections.py"
      via: "generate() calls all render_*() functions in sequence"
      pattern: "render_executive_summary"
    - from: "src/packets/docx_sections.py"
      to: "src/packets/docx_hotsheet.py"
      via: "reuses RELEVANT_COMMITTEE_KEYWORDS pattern for delegation committee filtering"
      pattern: "RELEVANT_COMMITTEE_KEYWORDS"
    - from: "src/packets/docx_sections.py"
      to: "src/packets/context.py"
      via: "all renderers read from TribePacketContext fields (senators, representatives, hazard_profile, awards)"
      pattern: "TribePacketContext"
    - from: "src/packets/docx_engine.py"
      to: "src/packets/docx_hotsheet.py"
      via: "generate() calls HotSheetRenderer.render_all_hotsheets() between delegation and hazard summary"
      pattern: "render_all_hotsheets"
---

<objective>
Add 4 new section renderers (executive summary, congressional delegation, hazard summary, structural asks) to docx_sections.py and update DocxEngine.generate() to produce a complete 8-section per-Tribe advocacy packet (Document 1).

Purpose: This plan completes DOC-05 by extending the Phase 7 document assembly from 4 sections (cover, TOC, Hot Sheets, appendix) to 8 sections. After this plan, DocxEngine.generate() produces a complete, print-ready per-Tribe advocacy packet with all data sections populated from TribePacketContext.
Output: Extended docx_sections.py with 7 total renderers, updated docx_engine.py with full section assembly, and test_doc_assembly.py with comprehensive tests.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/08-assembly-polish/08-CONTEXT.md
@.planning/phases/07-computation-docx/07-04-SUMMARY.md

@src/packets/context.py
@src/packets/docx_engine.py
@src/packets/docx_sections.py
@src/packets/docx_hotsheet.py
@src/packets/docx_styles.py
@src/packets/economic.py
@src/packets/orchestrator.py
@data/graph_schema.json
@tests/test_docx_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 new section renderers to docx_sections.py</name>
  <files>src/packets/docx_sections.py</files>
  <action>
Add 4 new render functions to the existing `src/packets/docx_sections.py` (which already has `render_cover_page`, `render_table_of_contents`, and `render_appendix`).

**Add new imports at top of file:**
```python
from src.packets.docx_hotsheet import RELEVANT_COMMITTEE_KEYWORDS
from src.packets.docx_styles import (
    CI_STATUS_LABELS,
    COLORS,
    StyleManager,
    add_status_badge,
    format_header_row,
    apply_zebra_stripe,
    set_cell_shading,
)
from src.packets.economic import TribeEconomicSummary
```
Note: `CI_STATUS_LABELS`, `COLORS`, `StyleManager`, and `add_status_badge` are already imported; add only `format_header_row`, `apply_zebra_stripe`, `set_cell_shading`, `RELEVANT_COMMITTEE_KEYWORDS`, and `TribeEconomicSummary` to the existing imports.

**Function 1: render_executive_summary(document, context, relevant_programs, economic_summary, style_manager)**
- Add heading "Executive Summary" in Heading 2 style
- Paragraph: "{context.tribe_name} -- {', '.join(context.states)}" in HS Title style
- Hazard snapshot: extract top 3 hazards from context.hazard_profile (same nesting pattern as docx_hotsheet._add_hazard_relevance). If no hazard data: "Hazard profile data pending."
- Funding summary: total obligation from context.awards (sum of award["obligation"]). If no awards: "No prior federal climate resilience awards on record. First-time applicant positioning available."
- Top programs: list first 3 relevant_programs by name with CI status badge inline (use add_status_badge pattern from TOC)
- Delegation snapshot: "{N} Senator(s) and {M} Representative(s) across {len(context.districts)} district(s)"
- Structural asks count: "5 structural policy asks identified" (hardcoded 5 per project design)
- End with page break
- Log: "Rendered executive summary for {tribe_name}"

**Function 2: render_delegation_section(document, context, style_manager)**
- Add heading "Congressional Delegation" in Heading 2 style
- If no senators and no representatives: add "Congressional delegation data not available." in HS Body and return with page break
- Create table with 5 columns: Name | Role | State | District | Relevant Committees
- Header row: use format_header_row(table, headers)
- Senators first: for each senator in context.senators:
  - name = senator.get("formatted_name", "Unknown")
  - role = "Senator"
  - state = senator.get("state", "")
  - district = "At-Large"
  - committees: filter senator.get("committees", []) using RELEVANT_COMMITTEE_KEYWORDS from docx_hotsheet.py (match if any keyword is a case-insensitive substring of committee_name). Join matches with "; ". If none match: ""
- Representatives next: for each rep in context.representatives:
  - name = rep.get("formatted_name", "Unknown")
  - role = "Representative"
  - state = rep.get("state", "")
  - district = rep.get("district", "")
  - committees: same filtering as senators
- Apply zebra striping: apply_zebra_stripe(table)
- Add delegation count summary: "{N} members with relevant committee assignments" where N = count of members with at least one matching committee
- End with page break
- Log: "Rendered delegation section with {total} members for {tribe_name}"

**Function 3: render_hazard_summary(document, context, style_manager)**
- Add heading "Climate Hazard Profile" in Heading 2 style
- Extract hazard data using same nesting pattern as docx_hotsheet._add_hazard_relevance:
  ```python
  hazard_profile = context.hazard_profile or {}
  fema_nri = hazard_profile.get("fema_nri") or hazard_profile.get("sources", {}).get("fema_nri", {})
  usfs_data = hazard_profile.get("usfs_wildfire") or hazard_profile.get("sources", {}).get("usfs_wildfire", {})
  ```
- If no fema_nri and no usfs_data: add "Hazard profile data not available for this Tribe." in HS Body, page break, return
- FEMA NRI composite section (if fema_nri has composite data):
  - Extract composite = fema_nri.get("composite", {})
  - "Overall Risk Rating: {risk_rating} (Score: {risk_score:.1f})"
  - "Social Vulnerability: {sovi_rating} (Score: {sovi_score:.1f})"
- Top 5 hazards table (if top_hazards exist):
  - Table with 4 columns: Hazard Type | Risk Score | Risk Rating | Expected Annual Loss
  - format_header_row(table, headers)
  - Iterate top 5 from fema_nri.get("top_hazards", [])[:5]
  - Format EAL as "$X,XXX" using f"${eal:,.0f}" pattern
  - apply_zebra_stripe(table)
- USFS wildfire section (if usfs_data):
  - "USFS Wildfire Risk Assessment"
  - risk_to_homes and likelihood values from usfs_data
- End with page break
- Log: "Rendered hazard summary for {tribe_name}"

**Function 4: render_structural_asks_section(document, structural_asks, context, style_manager)**
- Add heading "Structural Policy Asks" in Heading 2 style
- If not structural_asks: add "No structural policy asks defined." in HS Body, page break, return
- Brief intro: "The following structural policy changes would advance climate resilience funding for {context.tribe_name} and similarly situated Tribes."
- For each ask in structural_asks:
  - Ask name (bold) + urgency badge if ask.get("urgency"): "Ask Name [HIGH]"
  - Description: ask.get("description", "") in HS Body
  - Target: "Target: {ask.get('target', '')}" in HS Body if target exists
  - Programs advanced: list programs from ask.get("programs", []) by name -- look up names from context if possible, otherwise display program IDs
  - Evidence line from Tribe's data: build evidence connecting this ask to the Tribe's hazard/award data:
    - Check if any ask programs match context.awards program_ids -> "Active awards in affected programs"
    - Check context.hazard_profile for top hazard types -> "{top_hazard} risk profile"
    - Combine with "; " and render in HS Small style as "Evidence: {evidence}"
- End with page break
- Log: "Rendered {len(structural_asks)} structural asks for {tribe_name}"

**Critical notes:**
- All section renderers end with `document.add_page_break()` (NOT section break -- sections disrupt headers/footers)
- Use `paragraph.clear()` not `cell.text=""` for table header formatting (ghost run bug)
- Use `format_header_row()` from docx_styles.py for all tables (consistent dark header styling)
- Each function must handle gracefully when its data source is empty/None
- Import TribeEconomicSummary only for type hints; the function receives it as a parameter
  </action>
  <verify>
Run: `python -c "from src.packets.docx_sections import render_executive_summary, render_delegation_section, render_hazard_summary, render_structural_asks_section"` -- all 4 new functions import successfully
  </verify>
  <done>4 new section renderers added to docx_sections.py. All handle empty data gracefully. Use consistent patterns from Phase 7 (format_header_row, apply_zebra_stripe, RELEVANT_COMMITTEE_KEYWORDS, page breaks not section breaks).</done>
</task>

<task type="auto">
  <name>Task 2: Update DocxEngine.generate() with new section assembly order</name>
  <files>src/packets/docx_engine.py</files>
  <action>
**Update imports** in `src/packets/docx_engine.py`:

Change the existing import from docx_sections:
```python
from src.packets.docx_sections import (
    render_appendix,
    render_cover_page,
    render_table_of_contents,
)
```
To:
```python
from src.packets.docx_sections import (
    render_appendix,
    render_cover_page,
    render_delegation_section,
    render_executive_summary,
    render_hazard_summary,
    render_structural_asks_section,
    render_table_of_contents,
)
```

**Update the `generate()` method signature** (currently at line 164):

Change from:
```python
def generate(
    self,
    context: TribePacketContext,
    relevant_programs: list[dict],
    economic_summary: TribeEconomicSummary,
    structural_asks: list[dict],
    omitted_programs: list[dict] | None = None,
) -> Path:
```

To:
```python
def generate(
    self,
    context: TribePacketContext,
    relevant_programs: list[dict],
    economic_summary: TribeEconomicSummary,
    structural_asks: list[dict],
    omitted_programs: list[dict] | None = None,
    changes: list[dict] | None = None,
    previous_date: str | None = None,
) -> Path:
```

**Update the generate() method body** to insert new section calls in the correct order:

```python
document, style_manager = self.create_document()

# 1. Cover page (existing)
render_cover_page(document, context, style_manager)

# 2. Table of contents (existing)
render_table_of_contents(document, relevant_programs, context, style_manager)

# 3. Executive summary (NEW - DOC-05)
document.add_page_break()
render_executive_summary(
    document, context, relevant_programs, economic_summary, style_manager
)

# 4. Congressional delegation (NEW - DOC-05)
document.add_page_break()
render_delegation_section(document, context, style_manager)

# 5. Hot Sheets (existing) -- 8-12 relevant programs per Tribe
renderer = HotSheetRenderer(document, style_manager)
renderer.render_all_hotsheets(
    context, relevant_programs, economic_summary, structural_asks
)

# 6. Hazard profile summary (NEW - DOC-05)
document.add_page_break()
render_hazard_summary(document, context, style_manager)

# 7. Structural asks standalone (NEW - DOC-05)
document.add_page_break()
render_structural_asks_section(
    document, structural_asks, context, style_manager
)

# 8. Appendix (existing)
document.add_page_break()
render_appendix(document, omitted_programs or [], context, style_manager)

# 9. Save and return path
tribe_id = getattr(context, "tribe_id", "unknown")
output_path = self.save(document, tribe_id)
```

**Update the docstring** to reflect the new section order and optional parameters.

**Update the logger.info call** at the end of generate() to include total section count.

**Critical notes:**
- The `changes` and `previous_date` params are accepted but NOT used in this plan -- they are forward-compatible stubs for Plan 08-04 (OPS-03 change tracking). Do NOT create render_change_tracking() here.
- Each new section call is preceded by `document.add_page_break()` (NOT `document.add_section()`)
- The existing Hot Sheets section already handles its own internal page breaks between programs
- Keep the atomic save pattern (tmp + os.replace()) unchanged in save()
  </action>
  <verify>
Run: `python -c "from src.packets.docx_engine import DocxEngine; import inspect; sig = inspect.signature(DocxEngine.generate); assert 'changes' in sig.parameters; assert 'previous_date' in sig.parameters; print('OK: generate() has new params')"` -- verify signature updated
  </verify>
  <done>DocxEngine.generate() now assembles 8 sections in correct order. Forward-compatible changes/previous_date params accepted. All existing callers (orchestrator.generate_packet_from_context) continue to work via keyword defaults.</done>
</task>

<task type="auto">
  <name>Task 3: Create tests/test_doc_assembly.py</name>
  <files>tests/test_doc_assembly.py</files>
  <action>
Create `tests/test_doc_assembly.py` with comprehensive tests for the full document assembly.

**Reuse patterns from tests/test_docx_integration.py:**
- `_write_json(path, data)` helper for mock data files
- `_mock_programs()` for program inventory data
- Mock data builders for awards, hazards, structural asks

**Fixtures:**

`_mock_context()` -- returns a TribePacketContext with:
- tribe_id="epa_001", tribe_name="Alpha Tribe"
- states=["WA", "OR"], ecoregions=["pacific_northwest"]
- senators: 2 senators with formatted_name, state, committees (include "Appropriations" and "Energy" for committee keyword matching)
- representatives: 2 reps with formatted_name, state, district, committees (include "Indian Affairs" and "Natural Resources")
- awards: 3 awards with program_id="bia_tcr", cfda="15.156", obligation=100000/200000/50000
- hazard_profile with fema_nri (composite with risk_rating, risk_score, sovi_rating, sovi_score; top_hazards with 5 entries: Wildfire, Flooding, Earthquake, Drought, Hurricane each with type, risk_score, risk_rating, eal_total) and usfs_wildfire (risk_to_homes, likelihood)
- generated_at="2026-02-10T12:00:00+00:00"

`_mock_economic_summary()` -- returns a TribeEconomicSummary with mock data (import from src.packets.economic)

`_mock_structural_asks()` -- returns 5 structural ask dicts with name, description, target, urgency, programs (list of program IDs)

`_zero_data_context()` -- returns a TribePacketContext with:
- tribe_id="epa_999", tribe_name="Empty Tribe"
- No senators, no representatives, no awards, no hazard_profile, no districts

**Tests (minimum 10):**

1. `test_full_assembly_produces_all_sections` -- Generate full document via DocxEngine.generate(). Re-open with Document(path). Search paragraph texts for section markers: "Executive Summary", "Congressional Delegation", "Climate Hazard Profile", "Structural Policy Asks", "Appendix". All must be present.

2. `test_executive_summary_contains_tribe_name` -- Generate and re-open. Find paragraphs. At least one paragraph must contain "Alpha Tribe".

3. `test_executive_summary_references_programs` -- Generate and re-open. Executive summary area (paragraphs after "Executive Summary" heading, before next heading) must reference at least 1 program name from relevant_programs.

4. `test_delegation_table_has_senators_and_reps` -- Generate and re-open. Find tables in document. At least one table must have a header row with "Name" and "Role" columns. Data rows must include "Senator" and "Representative" role values.

5. `test_delegation_committee_filtering` -- Generate and re-open. Find paragraphs mentioning "relevant committee assignments". The count should be > 0 (since mock data includes matching committee keywords).

6. `test_hazard_summary_renders_top_hazards` -- Generate and re-open. Find paragraphs. At least one must contain "Wildfire" (the top hazard from mock data).

7. `test_hazard_summary_has_fema_ratings` -- Generate and re-open. Find paragraphs containing "Risk Rating" or "Social Vulnerability".

8. `test_structural_asks_includes_all_five` -- Generate and re-open. Count paragraphs in structural asks section. Should find all 5 ask names from mock data.

9. `test_zero_data_tribe_produces_valid_docx` -- Generate with _zero_data_context(). Document(path) succeeds (no crash). Verify "Hazard profile data not available" or similar graceful message appears. Verify "Congressional delegation data not available" appears.

10. `test_multi_state_tribe_delegation` -- Create context with states=["WA", "OR", "ID"], 4 senators (2 per state), 3 reps. Generate and verify all 7 members appear in delegation table.

11. `test_section_order_correct` -- Generate full document. Collect all Heading 2 paragraphs in order. Verify they appear in expected sequence: contains TOC heading, then "Executive Summary", then "Congressional Delegation", then Hot Sheet titles, then "Climate Hazard Profile", then "Structural Policy Asks", then "Appendix".

12. `test_document_opens_without_error` -- Generate document. Verify Document(str(path)) does not raise. Verify file size > 0.

13. `test_existing_tests_unaffected` -- Use subprocess to run `python -m pytest tests/test_docx_integration.py tests/test_docx_hotsheet.py tests/test_docx_styles.py tests/test_economic.py -v --tb=short` and assert returncode == 0.

**Critical test patterns:**
- Each test creates its own DocxEngine with tmp_path config
- Mock programs via _mock_programs() same as test_docx_integration.py
- Use `Document(str(path))` to re-read generated .docx files
- Search paragraphs via: `[p.text for p in doc.paragraphs]`
- Search tables via: `doc.tables`
- All tests must be self-contained (no shared state between tests)
- Use `encoding="utf-8"` on any file I/O

Run full suite at the end: `python -m pytest tests/ -v --tb=short`
  </action>
  <verify>
Run: `python -m pytest tests/test_doc_assembly.py -v --tb=short` -- all new tests pass
Run: `python -m pytest tests/ --tb=short` -- full suite passes (must be >= 224 total tests, all passing)
  </verify>
  <done>test_doc_assembly.py created with 13+ tests covering all new sections, zero-data edge case, multi-state Tribes, section ordering, and regression verification. Full test suite passes.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.packets.docx_sections import render_executive_summary, render_delegation_section, render_hazard_summary, render_structural_asks_section"` -- all 4 new renderers import
2. `python -c "from src.packets.docx_engine import DocxEngine; import inspect; sig = inspect.signature(DocxEngine.generate); params = list(sig.parameters.keys()); assert 'changes' in params and 'previous_date' in params"` -- forward-compatible params
3. `python -m pytest tests/test_doc_assembly.py -v --tb=short` -- all new tests pass
4. `python -m pytest tests/ --tb=short` -- full suite passes with 214 existing + 13+ new tests
5. Verify generated .docx contains paragraphs with all section headings in correct order
6. Verify zero-data Tribe .docx opens without error and has graceful fallback text
</verification>

<success_criteria>
- DocxEngine.generate() produces a complete 8-section document (cover, TOC, exec summary, delegation, Hot Sheets, hazard, structural asks, appendix)
- All 4 new renderers handle empty/None data without crashing
- Delegation table uses format_header_row + apply_zebra_stripe for consistent styling
- Delegation committee filtering uses RELEVANT_COMMITTEE_KEYWORDS from docx_hotsheet.py
- Hazard summary reuses the same nested data access pattern as HotSheetRenderer
- Generated .docx re-opens in python-docx without errors
- All 214 existing tests still pass
- 13+ new tests pass in test_doc_assembly.py
- changes/previous_date params accepted by generate() but not yet used (forward-compatible for Plan 08-04)
</success_criteria>

<output>
After completion, create `.planning/phases/08-assembly-polish/08-01-SUMMARY.md`
</output>
