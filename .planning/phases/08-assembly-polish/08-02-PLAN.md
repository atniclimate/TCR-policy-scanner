---
phase: 08-assembly-polish
plan: 02
type: execute
wave: 1
depends_on: ["07-04"]
files_modified:
  - src/packets/strategic_overview.py
  - src/packets/orchestrator.py
  - tests/test_strategic_overview.py
autonomous: true

must_haves:
  truths:
    - "StrategicOverviewGenerator produces a valid DOCX with 7 sections"
    - "Appropriations section includes all 16 program CI statuses from program_inventory.json"
    - "Ecoregion section covers all 7 ecoregions via EcoregionMapper.get_priority_programs()"
    - "Works with no LATEST-MONITOR-DATA.json (graceful fallback)"
    - "Cross-cutting framework includes 5 structural asks from graph_schema.json"
    - "Messaging guidance groups by advocacy goal (DEFEND/PROTECT/EXPAND)"
    - "PacketOrchestrator.generate_strategic_overview() method added"
    - "All 214 existing tests still pass"
  artifacts:
    - path: "src/packets/strategic_overview.py"
      provides: "StrategicOverviewGenerator class with generate() method producing STRATEGIC-OVERVIEW.docx"
      min_lines: 200
    - path: "src/packets/orchestrator.py"
      provides: "generate_strategic_overview() method added to PacketOrchestrator"
      contains: "generate_strategic_overview"
    - path: "tests/test_strategic_overview.py"
      provides: "8+ tests for strategic overview generation"
      min_lines: 200
  key_links:
    - from: "src/packets/strategic_overview.py"
      to: "src/packets/ecoregion.py"
      via: "StrategicOverviewGenerator uses EcoregionMapper for ecoregion priorities"
      pattern: "EcoregionMapper"
    - from: "src/packets/strategic_overview.py"
      to: "src/packets/docx_styles.py"
      via: "uses StyleManager and COLORS for document styling"
      pattern: "StyleManager"
    - from: "src/packets/strategic_overview.py"
      to: "src/packets/docx_hotsheet.py"
      via: "reuses FRAMING_BY_STATUS for messaging guidance tone classification"
      pattern: "FRAMING_BY_STATUS"
    - from: "src/packets/orchestrator.py"
      to: "src/packets/strategic_overview.py"
      via: "generate_strategic_overview() creates StrategicOverviewGenerator and calls generate()"
      pattern: "StrategicOverviewGenerator"
---

<objective>
Create the shared strategic overview document (Document 2) -- "FY26 Federal Funding Overview & Strategy" -- from existing v1.0 pipeline data files, and wire it into PacketOrchestrator.

Purpose: This plan delivers DOC-06, a single shared DOCX that provides the cross-cutting policy landscape used by all Tribal advocacy offices. Unlike per-Tribe packets (DOC-05), this document is generated once and covers all 16 programs, all 7 ecoregions, and the full structural policy framework.
Output: New strategic_overview.py module, updated orchestrator.py with generate_strategic_overview() method, and test_strategic_overview.py with comprehensive tests.
</objective>

<execution_context>
@D:\Claude-Workspace\.claude/get-shit-done/workflows/execute-plan.md
@D:\Claude-Workspace\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/08-assembly-polish/08-CONTEXT.md
@.planning/phases/07-computation-docx/07-04-SUMMARY.md

@src/packets/orchestrator.py
@src/packets/ecoregion.py
@src/packets/docx_engine.py
@src/packets/docx_styles.py
@src/packets/docx_hotsheet.py
@src/packets/economic.py
@data/program_inventory.json
@data/policy_tracking.json
@data/graph_schema.json
@config/scanner_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/packets/strategic_overview.py</name>
  <files>src/packets/strategic_overview.py</files>
  <action>
Create `src/packets/strategic_overview.py` with the `StrategicOverviewGenerator` class.

**Module docstring:**
```python
"""Strategic overview document generator (Document 2).

Generates a single shared DOCX -- "FY26 Federal Funding Overview & Strategy" --
from existing v1.0 pipeline data: program_inventory.json, policy_tracking.json,
graph_schema.json, and optionally LATEST-MONITOR-DATA.json.

This document is generated once (not per-Tribe) and provides the cross-cutting
policy landscape used by all Tribal advocacy offices.
"""
```

**Imports:**
```python
import json
import logging
import os
import tempfile
from datetime import datetime, timezone
from pathlib import Path

from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Inches, Pt

from src.packets.docx_hotsheet import FRAMING_BY_STATUS
from src.packets.docx_styles import (
    CI_STATUS_LABELS,
    COLORS,
    StyleManager,
    add_status_badge,
    apply_zebra_stripe,
    format_header_row,
)
from src.packets.ecoregion import EcoregionMapper
```

**Constants:**
```python
_MAX_DATA_FILE_BYTES: int = 10 * 1024 * 1024  # 10 MB

# Advocacy goal groupings derived from CI status
_GOAL_BY_STATUS: dict[str, str] = {
    "FLAGGED": "DEFEND",
    "AT_RISK": "DEFEND",
    "UNCERTAIN": "PROTECT",
    "STABLE_BUT_VULNERABLE": "PROTECT",
    "STABLE": "EXPAND",
    "SECURE": "EXPAND",
}

# FEMA program IDs for the dedicated FEMA analysis section
_FEMA_PROGRAM_IDS: set[str] = {
    "fema_bric", "fema_hmgp", "fema_fma", "fema_pdm",
    "fema_tribal_mitigation",
}
```

**Class: StrategicOverviewGenerator**

```python
class StrategicOverviewGenerator:
    """Generates the shared strategic overview DOCX (Document 2).

    Uses existing v1.0 data: program_inventory.json, policy_tracking.json,
    graph_schema.json, and optionally LATEST-MONITOR-DATA.json.

    Usage::

        generator = StrategicOverviewGenerator(config, programs)
        path = generator.generate(output_dir)
    """
```

**__init__(self, config: dict, programs: dict[str, dict]):**
- Store config and programs dict (keyed by program ID)
- Create EcoregionMapper(config)
- Load data sources via helper methods:
  - self.policy_tracking = self._load_json("data/policy_tracking.json")
  - self.graph_schema = self._load_json("data/graph_schema.json")
  - self.monitor_data = self._load_json("outputs/LATEST-MONITOR-DATA.json")  # optional, may be {}

**_load_json(self, path_str: str) -> dict:**
- Check if file exists; return {} if not
- Check file size < _MAX_DATA_FILE_BYTES; warn and return {} if over
- Load with encoding="utf-8"
- Return parsed dict
- Handle json.JSONDecodeError, OSError gracefully -> return {}

**generate(self, output_dir: Path) -> Path:**
- Create Document via standard python-docx pattern
- Create StyleManager(document)
- Configure page margins (1 inch all sides)
- Set up header/footer (similar to DocxEngine._setup_header_footer but with "FY26 Federal Funding Overview" header text)
- Render 7 sections in order:
  1. self._render_cover(document, style_manager)
  2. self._render_appropriations(document, style_manager)
  3. self._render_ecoregion_priorities(document, style_manager)
  4. self._render_science_threats(document, style_manager)
  5. self._render_fema_analysis(document, style_manager)
  6. self._render_cross_cutting_framework(document, style_manager)
  7. self._render_messaging_guidance(document, style_manager)
- Save using atomic write pattern (same as DocxEngine.save):
  - output_path = output_dir / "STRATEGIC-OVERVIEW.docx"
  - output_dir.mkdir(parents=True, exist_ok=True)
  - NamedTemporaryFile, close handle, save, os.replace, cleanup on error
- Return output_path

**_render_cover(self, document, style_manager):**
- Blank spacing paragraph
- "FY26 Federal Funding Overview & Strategy" in Heading 1
- "Tribal Climate Resilience Programs" in HS Title
- "A comprehensive analysis of 16 federal programs across 7 ecoregions" in HS Body
- Generation date in HS Body
- "CONFIDENTIAL -- For Advocacy Office Use Only" centered in HS Small
- Page break

**_render_appropriations(self, document, style_manager):**
- "Appropriations Landscape" heading (Heading 2)
- Brief intro: "Current CI status and funding positions for all 16 tracked federal climate resilience programs."
- Table with 5 columns: Program | Agency | CI Status | Funding Type | Authorization
- Iterate ALL programs in self.programs (sorted by name)
- For each program:
  - name, agency, ci_status (use CI_STATUS_LABELS for display), funding_type
  - Authorization status from self.policy_tracking if available: look up program ID in policy_tracking.get("programs", {}).get(program_id, {}).get("authorization_status", "")
- format_header_row + apply_zebra_stripe
- Summary counts: "{N} programs flagged or at risk, {M} stable or secure"
- Page break

**_render_ecoregion_priorities(self, document, style_manager):**
- "Ecoregion Strategic Priorities" heading (Heading 2)
- Brief intro: "Priority programs by ecoregion, based on geographic climate risk profiles."
- For each of 7 ecoregions (get list from EcoregionMapper):
  - Subheading with ecoregion name (Heading 3)
  - Get priority program IDs via self.ecoregion.get_priority_programs(ecoregion_id)
  - For each priority program: look up in self.programs, show name + CI status inline
  - If no priority programs for ecoregion: "No specific program priorities defined for this ecoregion."
- Page break

**_render_science_threats(self, document, style_manager):**
- "Science Infrastructure Threats" heading (Heading 2)
- If self.monitor_data is empty: "Monitor data not available. Run the scan pipeline to generate threat assessments." in HS Body, page break, return
- Extract alerts/findings from monitor_data:
  - Look for keys like "alerts", "findings", "threats", "monitors" (handle different monitor output formats)
  - If monitor_data has relevant alert data: render each alert with title, description, severity
  - Group by monitor type if possible (IIJA sunset, DHS funding cliff, reconciliation watch)
- Graceful fallback if monitor_data exists but has unexpected format: "Monitor data format not recognized. See outputs/LATEST-MONITOR-DATA.json for raw data."
- Page break

**_render_fema_analysis(self, document, style_manager):**
- "FEMA Programs Analysis" heading (Heading 2)
- Brief intro: "Dedicated analysis of FEMA climate resilience programs critical for Tribal hazard mitigation."
- Filter self.programs for _FEMA_PROGRAM_IDS
- For each FEMA program (sorted by name):
  - Program name (bold) in HS Body
  - CI status badge via add_status_badge
  - Description from program dict
  - Advocacy lever from program.get("advocacy_lever", "")
  - FEMA BCR methodology note: "FEMA programs use a 4:1 benefit-cost ratio standard for mitigation project evaluation."
- Page break

**_render_cross_cutting_framework(self, document, style_manager):**
- "Cross-Cutting Policy Framework" heading (Heading 2)
- Extract structural_asks from self.graph_schema.get("structural_asks", [])
- If no asks: "No structural asks defined in policy graph." in HS Body, page break, return
- Brief intro: "Five structural policy changes that would advance climate resilience funding across multiple programs."
- For each ask:
  - Ask name (bold, HS Body) + urgency badge if present
  - Description (HS Body)
  - Target (HS Body)
  - Programs advanced: list program names from ask.get("programs", []), looking up names in self.programs
- Page break

**_render_messaging_guidance(self, document, style_manager):**
- "Messaging Guidance" heading (Heading 2)
- Brief intro: "Advocacy framing organized by strategic goal. Each program's messaging is calibrated to its current CI status."
- Group programs by advocacy goal using _GOAL_BY_STATUS:
  - For each program: goal = _GOAL_BY_STATUS.get(program.get("ci_status", "STABLE"), "EXPAND")
  - Groups: DEFEND, PROTECT, EXPAND
- For each goal group (ordered DEFEND first, then PROTECT, then EXPAND):
  - Subheading: "DEFEND: Critical Programs Requiring Immediate Action" / "PROTECT: Programs Requiring Vigilance" / "EXPAND: Programs with Growth Opportunity" in Heading 3
  - For each program in this goal group:
    - Program name (bold)
    - Tightened language from program.get("tightened_language", "")
    - Advocacy lever from program.get("advocacy_lever", "")
    - Framing verbs from FRAMING_BY_STATUS (e.g., "protect, defend, restore")
- Final note: "All messaging is template-based from program inventory data. No AI-generated text." in HS Small
- (No page break at end -- final section)

**Critical notes:**
- Use encoding="utf-8" on all file I/O
- Use datetime.now(timezone.utc) for timestamps
- Atomic save pattern: NamedTemporaryFile -> close handle -> save -> os.replace -> cleanup
- Page breaks between sections (NOT section breaks)
- Handle missing data files gracefully (empty dict fallback)
- _MAX_DATA_FILE_BYTES size check before json.load()
- EcoregionMapper is initialized from config, not hardcoded paths
  </action>
  <verify>
Run: `python -c "from src.packets.strategic_overview import StrategicOverviewGenerator; print('Import OK')"` -- import succeeds
  </verify>
  <done>StrategicOverviewGenerator class created with generate() method producing 7-section STRATEGIC-OVERVIEW.docx. All data sources loaded from existing pipeline files with graceful fallbacks.</done>
</task>

<task type="auto">
  <name>Task 2: Add generate_strategic_overview() to orchestrator.py</name>
  <files>src/packets/orchestrator.py</files>
  <action>
Add a new method `generate_strategic_overview()` to the `PacketOrchestrator` class in `src/packets/orchestrator.py`.

**Add the method after the existing `_load_structural_asks()` method (around line 507):**

```python
def generate_strategic_overview(self) -> Path:
    """Generate the shared strategic overview DOCX (Document 2).

    Creates a single STRATEGIC-OVERVIEW.docx covering all 16 programs,
    7 ecoregions, and the full structural policy framework. This document
    is generated once (not per-Tribe).

    Uses lazy import of StrategicOverviewGenerator to avoid circular
    imports and keep the module lightweight when strategic overview
    is not needed.

    Returns:
        Path to the generated STRATEGIC-OVERVIEW.docx file.
    """
    from src.packets.strategic_overview import StrategicOverviewGenerator

    output_dir = Path(
        self.config.get("packets", {}).get("output_dir", "outputs/packets")
    )
    generator = StrategicOverviewGenerator(self.config, self.programs)
    path = generator.generate(output_dir)

    logger.info("Generated strategic overview: %s", path)
    return path
```

**Critical notes:**
- Use lazy import (inside method body) to avoid circular imports -- StrategicOverviewGenerator imports from docx_styles and ecoregion, which orchestrator also imports
- Use the same output_dir from config as DocxEngine (packets.output_dir)
- self.programs is already a dict keyed by program ID (set up in __init__), which is exactly what StrategicOverviewGenerator expects
- Do NOT modify any existing methods -- only add this new method
- Do NOT add any new top-level imports
  </action>
  <verify>
Run: `python -c "from src.packets.orchestrator import PacketOrchestrator; assert hasattr(PacketOrchestrator, 'generate_strategic_overview'); print('OK: method exists')"` -- method is accessible
  </verify>
  <done>PacketOrchestrator.generate_strategic_overview() added with lazy import of StrategicOverviewGenerator. No existing methods modified.</done>
</task>

<task type="auto">
  <name>Task 3: Create tests/test_strategic_overview.py</name>
  <files>tests/test_strategic_overview.py</files>
  <action>
Create `tests/test_strategic_overview.py` with comprehensive tests.

**Module docstring:**
```python
"""Tests for the strategic overview document generator (Plan 08-02).

Tests StrategicOverviewGenerator.generate() produces a valid 7-section DOCX
covering all 16 programs, 7 ecoregions, and structural policy framework.
All tests use tmp_path fixtures with mock data -- no network or real data
files required.
"""
```

**Imports:**
```python
import json
from pathlib import Path

import pytest
from docx import Document
```

**Helpers:**

```python
def _write_json(path: Path, data) -> None:
    """Write data as JSON to the given path, creating parent dirs."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f)
```

**Mock data builders:**

`_mock_programs()` -- returns a list of 16 program dicts (to match full inventory). Each must have at minimum:
- id, name, agency, ci_status, funding_type, description, advocacy_lever, tightened_language
- Include at least 2 FLAGGED/AT_RISK (DEFEND), 2 UNCERTAIN/STABLE_BUT_VULNERABLE (PROTECT), 2 STABLE/SECURE (EXPAND)
- Include at least 2 FEMA programs (fema_bric, fema_tribal_mitigation) with IDs matching _FEMA_PROGRAM_IDS
- Can use abbreviated descriptions for mock data

`_mock_policy_tracking()` -- returns a dict with structure:
```python
{"programs": {"bia_tcr": {"authorization_status": "Authorized through FY27"}, ...}}
```

`_mock_graph_schema()` -- returns a dict with:
```python
{"structural_asks": [
    {"name": "Ask 1", "description": "Description 1", "target": "Congress", "urgency": "HIGH", "programs": ["bia_tcr"]},
    ... (5 total asks)
]}
```

`_mock_monitor_data()` -- returns a dict with:
```python
{"alerts": [{"title": "IIJA Sunset Warning", "description": "IIJA authorization expires...", "severity": "high"}]}
```

`_mock_ecoregion_config()` -- returns a valid ecoregion config dict with 7 ecoregions, each with states and priority_programs lists.

**Fixture: `setup_data_files(tmp_path)`**
- Write all mock data files to tmp_path:
  - data/program_inventory.json (list of 16 programs)
  - data/policy_tracking.json
  - data/graph_schema.json
  - data/ecoregion_config.json
  - outputs/LATEST-MONITOR-DATA.json
- Build config dict with packets.output_dir pointing to tmp_path / "output" and ecoregion.data_path pointing to tmp_path / "data/ecoregion_config.json"
- Return (config, programs_dict) where programs_dict = {p["id"]: p for p in programs_list}

**Tests (minimum 8):**

1. `test_generates_valid_docx` -- Generate STRATEGIC-OVERVIEW.docx. Verify file exists, size > 0, Document(str(path)) succeeds without error.

2. `test_has_seven_sections` -- Generate and re-open. Search Heading 2 paragraphs. Expect 7 section headings: cover title area, "Appropriations Landscape", "Ecoregion Strategic Priorities", "Science Infrastructure Threats", "FEMA Programs Analysis", "Cross-Cutting Policy Framework", "Messaging Guidance".

3. `test_appropriations_includes_all_programs` -- Generate and re-open. Find the appropriations table. Verify it has 16 data rows (one per program) plus header row.

4. `test_ecoregion_covers_all_seven` -- Generate and re-open. Search paragraphs for Heading 3 entries within ecoregion section. Should find 7 ecoregion subheadings.

5. `test_graceful_no_monitor_data` -- Set up data files WITHOUT outputs/LATEST-MONITOR-DATA.json. Generate successfully. Verify "Monitor data not available" text appears in the science threats section.

6. `test_cross_cutting_has_five_asks` -- Generate and re-open. Find all 5 structural ask names from mock data in document paragraphs.

7. `test_messaging_groups_by_goal` -- Generate and re-open. Search for "DEFEND", "PROTECT", "EXPAND" group headings. All three must appear.

8. `test_fema_analysis_section` -- Generate and re-open. Search for FEMA program names (fema_bric, fema_tribal_mitigation display names). Both must appear.

9. `test_cover_page_content` -- Generate and re-open. First paragraphs should contain "FY26 Federal Funding Overview" and "CONFIDENTIAL".

10. `test_orchestrator_integration` -- Create a minimal PacketOrchestrator with mock config and programs. Call generate_strategic_overview(). Verify it returns a Path to a valid .docx file.

**Critical test patterns:**
- Each test uses tmp_path for isolated file system
- Mock data files created in tmp_path with correct relative structure
- Config dict points all paths to tmp_path locations
- Use `Document(str(path))` to re-read generated .docx files
- Search paragraphs via: `[p.text for p in doc.paragraphs]`
- Handle ecoregion config path: StrategicOverviewGenerator uses EcoregionMapper which reads from config path
- Use `encoding="utf-8"` on all file I/O
- Do NOT modify any existing test files

Run full suite at the end: `python -m pytest tests/ -v --tb=short`
  </action>
  <verify>
Run: `python -m pytest tests/test_strategic_overview.py -v --tb=short` -- all new tests pass
Run: `python -m pytest tests/ --tb=short` -- full suite passes (214 existing + new tests from 08-01 and 08-02)
  </verify>
  <done>test_strategic_overview.py created with 10+ tests covering all 7 sections, graceful fallback, messaging grouping, FEMA analysis, and orchestrator integration. Full test suite passes.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.packets.strategic_overview import StrategicOverviewGenerator"` -- import works
2. `python -c "from src.packets.orchestrator import PacketOrchestrator; assert hasattr(PacketOrchestrator, 'generate_strategic_overview')"` -- method exists
3. `python -m pytest tests/test_strategic_overview.py -v --tb=short` -- all strategic overview tests pass
4. `python -m pytest tests/ --tb=short` -- full suite passes (214 existing + all new Phase 8 tests)
5. Verify STRATEGIC-OVERVIEW.docx contains all 7 section headings
6. Verify STRATEGIC-OVERVIEW.docx contains all 16 program names in appropriations table
7. Verify generation succeeds with missing LATEST-MONITOR-DATA.json (graceful fallback)
</verification>

<success_criteria>
- StrategicOverviewGenerator.generate() produces STRATEGIC-OVERVIEW.docx with 7 sections
- Appropriations table has 16 rows (one per program) with CI status for each
- Ecoregion section covers all 7 ecoregions with priority programs from EcoregionMapper
- Science threats section gracefully handles missing LATEST-MONITOR-DATA.json
- Cross-cutting framework includes all 5 structural asks from graph_schema.json
- Messaging guidance groups programs by DEFEND/PROTECT/EXPAND advocacy goals
- FEMA analysis section isolates FEMA-specific programs with BCR methodology note
- Atomic save pattern used (tmp file + os.replace())
- PacketOrchestrator.generate_strategic_overview() returns Path to generated file
- All 214 existing tests still pass
- 10+ new tests pass in test_strategic_overview.py
</success_criteria>

<output>
After completion, create `.planning/phases/08-assembly-polish/08-02-SUMMARY.md`
</output>
