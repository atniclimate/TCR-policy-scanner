---
phase: 12-award-population
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/packets/awards.py
  - tests/test_awards.py
autonomous: true

must_haves:
  truths:
    - "Awards are deduplicated by Award ID before matching"
    - "Matched awards include year-by-year obligation breakdown in cache files"
    - "Consortium/inter-Tribal awards are logged separately, not attributed to individual Tribes"
    - "Cache files include fiscal_year_range, yearly_obligations, and trend fields"
    - "Zero-award Tribes still get a cache file with first-time applicant messaging"
  artifacts:
    - path: "src/packets/awards.py"
      provides: "Enhanced TribalAwardMatcher with dedup, year-by-year cache, consortium detection"
      contains: "yearly_obligations"
    - path: "tests/test_awards.py"
      provides: "Unit tests for matching, dedup, cache schema, consortium detection"
      min_lines: 100
  key_links:
    - from: "src/packets/awards.py"
      to: "data/award_cache/*.json"
      via: "write_cache() producing enhanced schema with yearly_obligations"
      pattern: "yearly_obligations"
    - from: "src/packets/awards.py"
      to: "src/config.py"
      via: "FISCAL_YEAR_INT for dynamic year range in cache metadata"
      pattern: "FISCAL_YEAR_INT"
---

<objective>
Extend the TribalAwardMatcher to deduplicate awards by ID, write enhanced cache files with year-by-year obligation breakdowns, detect consortium awards, and compute funding trends. This is the matching and caching engine for Phase 12.

Purpose: The existing matcher writes a flat cache schema with just awards/total_obligation/award_count. This plan adds deduplication (multi-year awards span fiscal year queries), per-FY obligation breakdown for trend analysis in packets, consortium detection (logged but not attributed per CONTEXT decision), and a trend indicator.

Output: Enhanced `TribalAwardMatcher` with `deduplicate_awards()`, updated `write_cache()` schema, consortium detection, and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-award-population/12-RESEARCH.md
@.planning/phases/12-award-population/12-CONTEXT.md
@src/packets/awards.py
@src/packets/registry.py
@src/config.py
@src/paths.py
@data/tribal_aliases.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dedup, consortium detection, enhanced cache schema</name>
  <files>src/packets/awards.py</files>
  <action>
  Make these changes to `src/packets/awards.py`:

  1. **Add import** at top: `from src.config import FISCAL_YEAR_INT`

  2. **Add consortium detection patterns** as a module-level constant:
     ```python
     _CONSORTIUM_PATTERNS = [
         "inter tribal", "intertribal", "inter-tribal",
         "consortium", "council of", "united tribes",
         "indian health board", "tribal council inc",
         "association of", "united south and eastern",
     ]
     ```

  3. **Add `_is_consortium(recipient_name: str) -> bool` module-level function:**
     - Lowercases the name, checks if any pattern from `_CONSORTIUM_PATTERNS` appears in it
     - Returns True if consortium pattern detected

  4. **Add `deduplicate_awards()` static method** to `TribalAwardMatcher`:
     ```python
     @staticmethod
     def deduplicate_awards(
         awards_by_cfda: dict[str, list[dict]],
     ) -> dict[str, list[dict]]:
     ```
     - Iterates all awards across all CFDAs
     - Deduplicates by `"Award ID"` field. If Award ID is empty/missing, use composite key: `f"{recipient_name}|{cfda}|{obligation}|{start_date}"`
     - Keeps the FIRST occurrence (preserves the earliest fiscal year appearance)
     - Returns a new dict with same structure but deduplicated lists
     - Logs: "Deduplicated {original} -> {deduped} awards (removed {N} duplicates)"

  5. **Update `match_all_awards()` method:**
     - Before the matching loop, detect and separate consortium awards:
       ```python
       consortium_awards: list[dict] = []
       ```
     - In the loop, before calling `match_recipient_to_tribe()`, check `_is_consortium(recipient_name)`. If True, append to `consortium_awards` list and `continue` (skip matching).
     - After the loop, log consortium summary: "Found {N} consortium/inter-Tribal awards totaling ${X:,.0f} (not attributed to individual Tribes)"
     - Add `consortium_awards` to the return value. Change the return type: instead of returning just `dict[str, list[dict]]`, return a tuple:
       Actually, to maintain backward compatibility with `run()` and `run_async()`, do NOT change the return type. Instead, store consortium awards as `self._last_consortium_awards` attribute and log them. The orchestration script (Plan 12-03) will access this attribute if needed.

  6. **Update `write_cache()` method** for enhanced schema:
     - Accept optional parameters: `fy_start: int | None = None, fy_end: int | None = None`
     - Default: `fy_end = FISCAL_YEAR_INT`, `fy_start = FISCAL_YEAR_INT - 4`
     - Build `yearly_obligations` dict: for each FY in range, sum obligations from awards whose `start_date` falls in that FY (use the `_fiscal_year` field if present, otherwise parse `start_date` to determine FY)
     - Compute `trend` string: compare first half vs second half of yearly totals:
       - If no awards: `"none"`
       - If only awards in last 2 years: `"new"`
       - If second half sum > first half sum * 1.2: `"increasing"`
       - If second half sum < first half sum * 0.8: `"decreasing"`
       - Otherwise: `"stable"`
     - Enhanced cache schema per Tribe:
       ```python
       cache_data = {
           "tribe_id": tribe_id,
           "tribe_name": tribe["name"],
           "fiscal_year_range": {"start": fy_start, "end": fy_end},
           "awards": awards,
           "total_obligation": total_obligation,
           "award_count": len(awards),
           "cfda_summary": cfda_summary,
           "yearly_obligations": yearly_obligations,
           "trend": trend,
       }
       ```
     - Keep the `no_awards_context` field for zero-award Tribes (existing behavior)
     - Use `encoding="utf-8"` on all `open()` calls (already done, just verify)

  7. **Add `_determine_award_fy(award: dict) -> int | None` module-level helper:**
     - If `_fiscal_year` key exists, return it
     - Else parse `start_date` (format "YYYY-MM-DD"): if month >= 10, FY = year + 1, else FY = year
     - Return None if start_date is missing/unparseable

  Do NOT change the `__init__()` method, `match_recipient_to_tribe()` method, or the `run()`/`run_async()` methods. The existing matching logic is correct. Only extend `match_all_awards()` and `write_cache()`.
  </action>
  <verify>
  - `python -c "from src.packets.awards import TribalAwardMatcher, _is_consortium; assert _is_consortium('INTER TRIBAL COUNCIL OF ARIZONA'); assert not _is_consortium('NAVAJO NATION'); print('OK')"` prints OK
  - `python -c "from src.packets.awards import TribalAwardMatcher; assert hasattr(TribalAwardMatcher, 'deduplicate_awards'); print('OK')"` prints OK
  - `ruff check src/packets/awards.py` passes clean
  </verify>
  <done>
  TribalAwardMatcher has deduplicate_awards(), consortium detection in match_all_awards(), enhanced write_cache() with yearly_obligations/trend/fiscal_year_range, and _determine_award_fy() helper.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for matching, dedup, cache schema, consortium detection</name>
  <files>tests/test_awards.py</files>
  <action>
  Create `tests/test_awards.py` with comprehensive tests. Mock `TribalRegistry` to avoid needing real data files. Use `tmp_path` fixture for cache directory.

  Tests to write:

  1. **test_is_consortium_positive**: Assert `_is_consortium()` returns True for: "INTER TRIBAL COUNCIL OF ARIZONA", "NORTHWEST PORTLAND AREA INDIAN HEALTH BOARD", "ALEUTIAN PRIBILOF ISLANDS ASSOCIATION INC".

  2. **test_is_consortium_negative**: Assert `_is_consortium()` returns False for: "NAVAJO NATION", "MUCKLESHOOT INDIAN TRIBE", "STANDING ROCK SIOUX TRIBE".

  3. **test_deduplicate_by_award_id**: Create awards_by_cfda with duplicate Award IDs across two CFDAs. Assert dedup removes the duplicates and keeps the first occurrence.

  4. **test_deduplicate_empty_award_id_fallback**: Create awards with empty Award ID but different composite keys. Assert they are NOT deduplicated (they're different awards). Create awards with empty Award ID but same composite key. Assert they ARE deduplicated.

  5. **test_determine_award_fy_from_fiscal_year_field**: Assert `_determine_award_fy({"_fiscal_year": 2024})` returns 2024.

  6. **test_determine_award_fy_from_start_date**: Assert `_determine_award_fy({"start_date": "2023-11-15"})` returns 2024 (Nov is in FY24). Assert `_determine_award_fy({"start_date": "2024-03-15"})` returns 2024 (Mar is in FY24).

  7. **test_write_cache_enhanced_schema**: Create a minimal TribalAwardMatcher with mocked registry (1-2 Tribes). Call `write_cache()` with sample matched awards. Read the output JSON and assert:
     - `fiscal_year_range` has `start` and `end` keys
     - `yearly_obligations` is a dict with FY keys
     - `trend` is one of: "none", "new", "increasing", "decreasing", "stable"
     - `cfda_summary` is populated
     - For zero-award Tribe, `no_awards_context` is present

  8. **test_write_cache_trend_increasing**: Provide awards heavily weighted to later years. Assert `trend == "increasing"`.

  9. **test_write_cache_trend_none**: Provide no awards. Assert `trend == "none"`.

  10. **test_match_all_awards_skips_consortium**: Create awards_by_cfda with a consortium recipient. Assert it is NOT in matched output. Assert `self._last_consortium_awards` contains the consortium award.

  For mocking TribalRegistry, create a minimal mock:
  ```python
  class MockRegistry:
      def __init__(self, tribes):
          self._tribes = tribes
      def get_all(self):
          return self._tribes
      def get_by_id(self, tribe_id):
          return next((t for t in self._tribes if t["tribe_id"] == tribe_id), None)
  ```

  To construct a TribalAwardMatcher without hitting the file system, either:
  - Mock the `__init__` to set attributes directly, OR
  - Create temp alias/registry files and pass config pointing to them

  Prefer the temp file approach for realistic testing.
  </action>
  <verify>
  - `python -m pytest tests/test_awards.py -v` -- all tests pass
  - `ruff check tests/test_awards.py` passes clean
  </verify>
  <done>
  10+ unit tests verify consortium detection, deduplication (by Award ID and composite fallback), FY determination, enhanced cache schema (yearly_obligations, trend, fiscal_year_range), and consortium filtering in match_all_awards. All pass.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_awards.py -v` -- all tests pass
- `ruff check src/packets/awards.py tests/test_awards.py` -- zero violations
- `python -m pytest tests/ -v` -- all existing tests still pass (no regressions)
- Cache schema includes fiscal_year_range, yearly_obligations, trend fields
</verification>

<success_criteria>
1. Awards deduplicated by Award ID (with composite key fallback for empty IDs)
2. Consortium awards detected and logged, not attributed to individual Tribes
3. Cache files include fiscal_year_range, yearly_obligations dict, and trend indicator
4. Trend correctly computed as increasing/decreasing/stable/new/none
5. Zero-award Tribes still get cache files with no_awards_context
6. All new tests pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-award-population/12-02-SUMMARY.md`
</output>
