---
phase: 12-award-population
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scrapers/usaspending.py
  - tests/test_usaspending_batch.py
autonomous: true

must_haves:
  truths:
    - "USASpending scraper can fetch Tribal awards for a single CFDA in a single fiscal year"
    - "All 14 unique CFDAs from program inventory are mapped in CFDA_TO_PROGRAM"
    - "Award type codes include direct payments (06, 10) alongside grants (02-05)"
    - "Fiscal year range is dynamic (derived from config, not hardcoded)"
    - "Per-year fetch paginates fully and does not silently truncate at 10K"
  artifacts:
    - path: "src/scrapers/usaspending.py"
      provides: "fetch_tribal_awards_by_year() and fetch_all_tribal_awards_multi_year()"
      contains: "fetch_tribal_awards_by_year"
    - path: "tests/test_usaspending_batch.py"
      provides: "Unit tests for batch query engine"
      min_lines: 80
  key_links:
    - from: "src/scrapers/usaspending.py"
      to: "src/config.py"
      via: "FISCAL_YEAR_INT import for dynamic year range"
      pattern: "FISCAL_YEAR_INT"
    - from: "src/scrapers/usaspending.py"
      to: "USASpending API"
      via: "spending_by_award endpoint with per-year time_period filter"
      pattern: "time_period.*start_date.*end_date"
---

<objective>
Extend the USASpending scraper to support per-fiscal-year batch querying across all 14 CFDAs with expanded award type codes. This is the data acquisition engine for Phase 12.

Purpose: The existing scraper queries a single fiscal year with grant-only codes (02-05) and is missing 2 CFDA mappings. This plan adds 5-year per-(CFDA, FY) querying, direct payment codes (06, 10), and the 2 missing CFDAs (11.483, 66.038), producing the raw award data that Plan 12-02 will match and Plan 12-03 will orchestrate.

Output: Extended `USASpendingScraper` with `fetch_tribal_awards_by_year()` and `fetch_all_tribal_awards_multi_year()` methods, plus unit tests mocking API responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-award-population/12-RESEARCH.md
@.planning/phases/12-award-population/12-CONTEXT.md
@src/scrapers/usaspending.py
@src/config.py
@src/paths.py
@src/scrapers/base.py
@data/program_inventory.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CFDA map and add per-year fetch method</name>
  <files>src/scrapers/usaspending.py</files>
  <action>
  Make these changes to `src/scrapers/usaspending.py`:

  1. **Add 2 missing CFDA mappings** to `CFDA_TO_PROGRAM`:
     - `"11.483": "noaa_tribal"`
     - `"66.038": "epa_tribal_air"`
     (This brings the map from 12 to 14 entries, matching the program inventory.)

  2. **Define TRIBAL_AWARD_TYPE_CODES** as a module-level constant:
     ```python
     TRIBAL_AWARD_TYPE_CODES = ["02", "03", "04", "05", "06", "10"]
     ```
     02-05 = grants/cooperative agreements, 06 = direct payments with unrestricted use, 10 = direct payments with specified use. Do NOT include 07/08 (loans), 09 (insurance), or 11 (other).

  3. **Update existing `fetch_tribal_awards_for_cfda()`** to use `TRIBAL_AWARD_TYPE_CODES` instead of the hardcoded `["02", "03", "04", "05"]` list.

  4. **Add `fetch_tribal_awards_by_year()` method** to `USASpendingScraper`:
     ```python
     async def fetch_tribal_awards_by_year(
         self, session: aiohttp.ClientSession, cfda: str, fy: int,
     ) -> list[dict]:
     ```
     - Computes fiscal year boundaries: `start = f"{fy - 1}-10-01"`, `end = f"{fy}-09-30"`
     - Uses same payload structure as `fetch_tribal_awards_for_cfda()` but with:
       - `"award_type_codes": TRIBAL_AWARD_TYPE_CODES`
       - `"time_period": [{"start_date": start, "end_date": end}]`
     - Full pagination loop (same pattern as existing `fetch_tribal_awards_for_cfda`)
     - Add safety check: if page reaches 100 (10K records), log a WARNING about potential truncation and break
     - Returns list of raw award dicts (each dict gets an extra `"_fiscal_year": fy` field injected for downstream use)

  5. **Add `fetch_all_tribal_awards_multi_year()` method** to `USASpendingScraper`:
     ```python
     async def fetch_all_tribal_awards_multi_year(
         self, fy_start: int | None = None, fy_end: int | None = None,
     ) -> dict[str, list[dict]]:
     ```
     - Defaults: `fy_end = FISCAL_YEAR_INT`, `fy_start = FISCAL_YEAR_INT - 4` (5-year window)
     - Import `FISCAL_YEAR_INT` from `src.config` (already imported via `FISCAL_YEAR_SHORT` etc.)
     - Iterates over all CFDAs in `CFDA_TO_PROGRAM` x all fiscal years in range
     - Creates a single `aiohttp.ClientSession`, calls `fetch_tribal_awards_by_year(session, cfda, fy)` for each (cfda, fy) pair sequentially (not parallel -- respect rate limits)
     - Sleeps 0.5s between requests (same as existing `fetch_all_tribal_awards`)
     - Catches exceptions per-(cfda, fy) so one failure doesn't abort the batch
     - Returns `dict[str, list[dict]]` keyed by CFDA -> flat list of all awards across years for that CFDA
     - Logs total: "{N} awards across {M} CFDAs, {Y} fiscal years, {Q} queries"

  6. **Add FISCAL_YEAR_INT to imports** at top of file:
     Change `from src.config import FISCAL_YEAR_SHORT, FISCAL_YEAR_START, FISCAL_YEAR_END` to also include `FISCAL_YEAR_INT`.

  Do NOT modify `_normalize()`, `_fetch_obligations()`, or `scan()` -- those are for the pipeline, not for award population. Do NOT remove the existing `fetch_tribal_awards_for_cfda()` or `fetch_all_tribal_awards()` methods (they're still used by `TribalAwardMatcher.run()`).
  </action>
  <verify>
  - `python -c "from src.scrapers.usaspending import CFDA_TO_PROGRAM, TRIBAL_AWARD_TYPE_CODES; assert len(CFDA_TO_PROGRAM) == 14; assert '06' in TRIBAL_AWARD_TYPE_CODES; assert '11.483' in CFDA_TO_PROGRAM; assert '66.038' in CFDA_TO_PROGRAM; print('OK')"` prints OK
  - `python -c "from src.scrapers.usaspending import USASpendingScraper; assert hasattr(USASpendingScraper, 'fetch_tribal_awards_by_year'); assert hasattr(USASpendingScraper, 'fetch_all_tribal_awards_multi_year'); print('OK')"` prints OK
  - `ruff check src/scrapers/usaspending.py` passes clean
  </verify>
  <done>
  USASpendingScraper has 14 CFDA mappings, expanded award type codes (02-06,10), a `fetch_tribal_awards_by_year(session, cfda, fy)` method with per-year boundaries and pagination, and a `fetch_all_tribal_awards_multi_year()` orchestrator that queries all (CFDA, FY) pairs with rate limiting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for batch query engine</name>
  <files>tests/test_usaspending_batch.py</files>
  <action>
  Create `tests/test_usaspending_batch.py` with tests covering the new methods. Use `unittest.mock.AsyncMock` to mock `_request_with_retry`. Use the project's existing test patterns (`pytest` with plain functions or classes).

  Tests to write:

  1. **test_cfda_map_completeness**: Assert `len(CFDA_TO_PROGRAM) == 14`, assert `"11.483"` and `"66.038"` are present, assert all 14 values are non-empty strings.

  2. **test_award_type_codes_expanded**: Assert `TRIBAL_AWARD_TYPE_CODES == ["02", "03", "04", "05", "06", "10"]`.

  3. **test_fetch_by_year_builds_correct_payload**: Mock `_request_with_retry` to return `{"results": [], "page_metadata": {"hasNext": False}}`. Call `fetch_tribal_awards_by_year(session, "15.156", 2024)`. Assert the payload passed to `_request_with_retry` has:
     - `time_period[0].start_date == "2023-10-01"` and `end_date == "2024-09-30"`
     - `award_type_codes == ["02", "03", "04", "05", "06", "10"]`
     - `program_numbers == ["15.156"]`
     - `recipient_type_names == ["indian_native_american_tribal_government"]`

  4. **test_fetch_by_year_paginates**: Mock `_request_with_retry` to return results on page 1 with `hasNext: True`, then page 2 with `hasNext: False`. Assert all results from both pages are returned. Assert `_fiscal_year` field is injected into each result.

  5. **test_fetch_by_year_truncation_warning**: Mock `_request_with_retry` to return results on 100 pages all with `hasNext: True`. Assert the method stops at page 100 (doesn't loop forever). Use `caplog` to assert a WARNING about potential truncation was logged.

  6. **test_multi_year_default_range**: Mock `fetch_tribal_awards_by_year` on the scraper instance. Call `fetch_all_tribal_awards_multi_year()` with no args. Assert it was called with FISCAL_YEAR_INT and 4 years prior (5 years total), for all 14 CFDAs = 70 calls total.

  7. **test_multi_year_per_cfda_failure_isolation**: Mock `fetch_tribal_awards_by_year` to raise `Exception` for one specific (cfda, fy) and return results for others. Assert the method completes, the failed CFDA still has an entry (possibly empty), and non-failed CFDAs have their results.

  Use a helper function or fixture to create a configured `USASpendingScraper` instance:
  ```python
  def _make_scraper():
      config = {"sources": {"usaspending": {"base_url": "https://api.usaspending.gov/api/v2"}}}
      return USASpendingScraper(config)
  ```

  All tests should be async where needed (use `@pytest.mark.asyncio` or `asyncio.run()`).
  </action>
  <verify>
  - `python -m pytest tests/test_usaspending_batch.py -v` -- all tests pass
  - `ruff check tests/test_usaspending_batch.py` passes clean
  </verify>
  <done>
  7+ unit tests verify CFDA completeness, expanded award type codes, per-year payload construction, pagination, truncation safety, multi-year orchestration, and per-CFDA failure isolation. All pass.
  </done>
</task>

</tasks>

<verification>
- `python -c "from src.scrapers.usaspending import CFDA_TO_PROGRAM; assert len(CFDA_TO_PROGRAM) == 14"` succeeds
- `python -m pytest tests/test_usaspending_batch.py -v` -- all tests pass
- `ruff check src/scrapers/usaspending.py tests/test_usaspending_batch.py` -- zero violations
- `python -m pytest tests/ -v` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
1. CFDA_TO_PROGRAM has 14 entries (including 11.483 and 66.038)
2. TRIBAL_AWARD_TYPE_CODES includes direct payments (06, 10)
3. fetch_tribal_awards_by_year() queries a single (CFDA, FY) pair with correct date boundaries
4. fetch_all_tribal_awards_multi_year() orchestrates 14 CFDAs x 5 FYs = 70 queries with rate limiting
5. Pagination safety: stops at page 100 with warning (10K record ceiling)
6. All new tests pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-award-population/12-01-SUMMARY.md`
</output>
