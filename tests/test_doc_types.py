"""Tests for DocumentTypeConfig system (Plan 14-02, Task 1).

Verifies document type configuration, audience filtering, air gap compliance,
header/footer formatting, and filename generation for all 4 document types.
"""

import pytest

from src.config import FISCAL_YEAR_SHORT
from src.packets.doc_types import (
    DOC_A,
    DOC_B,
    DOC_C,
    DOC_D,
    DOC_TYPES,
)


# ---------------------------------------------------------------------------
# Air gap forbidden strings -- must never appear in any config value
# ---------------------------------------------------------------------------

FORBIDDEN_STRINGS = [
    "TCR Policy Scanner",
    "ATNI",
    "NCAI",
    "IndigenousACCESS",
    "Generated by",
    "Tribal Advocacy Packet",
]


class TestDocumentTypeConfigBasics:
    """Basic validation of all 4 document type configurations."""

    def test_all_four_configs_have_distinct_doc_types(self):
        """Each config has a unique doc_type value (A, B, C, D)."""
        types = {DOC_A.doc_type, DOC_B.doc_type, DOC_C.doc_type, DOC_D.doc_type}
        assert types == {"A", "B", "C", "D"}

    def test_doc_types_dict_contains_all_four(self):
        """DOC_TYPES dict maps all 4 type letters to their configs."""
        assert set(DOC_TYPES.keys()) == {"A", "B", "C", "D"}
        assert DOC_TYPES["A"] is DOC_A
        assert DOC_TYPES["B"] is DOC_B
        assert DOC_TYPES["C"] is DOC_C
        assert DOC_TYPES["D"] is DOC_D

    def test_configs_are_frozen(self):
        """DocumentTypeConfig instances are immutable (frozen=True)."""
        with pytest.raises(AttributeError):
            DOC_A.doc_type = "X"


class TestConfidentiality:
    """Verify confidentiality flags match audience targeting."""

    def test_internal_docs_are_confidential(self):
        """DOC_A (internal/tribal) and DOC_C (internal/regional) are confidential."""
        assert DOC_A.confidential is True
        assert DOC_C.confidential is True

    def test_congressional_docs_are_not_confidential(self):
        """DOC_B (congressional/tribal) and DOC_D (congressional/regional) are not confidential."""
        assert DOC_B.confidential is False
        assert DOC_D.confidential is False


class TestContentFlags:
    """Verify content inclusion flags per audience."""

    def test_internal_docs_include_strategy(self):
        """Internal docs (A, C) include strategy content."""
        assert DOC_A.include_strategy is True
        assert DOC_C.include_strategy is True

    def test_congressional_docs_exclude_strategy(self):
        """Congressional docs (B, D) exclude strategy content."""
        assert DOC_B.include_strategy is False
        assert DOC_D.include_strategy is False

    def test_doc_a_includes_all_content(self):
        """DOC_A has all include_* flags set to True."""
        assert DOC_A.include_strategy is True
        assert DOC_A.include_advocacy_lever is True
        assert DOC_A.include_member_approach is True
        assert DOC_A.include_messaging_framework is True

    def test_doc_b_excludes_all_internal_content(self):
        """DOC_B has all include_* flags set to False."""
        assert DOC_B.include_strategy is False
        assert DOC_B.include_advocacy_lever is False
        assert DOC_B.include_member_approach is False
        assert DOC_B.include_messaging_framework is False

    def test_doc_c_excludes_messaging_framework(self):
        """DOC_C includes strategy but excludes messaging framework."""
        assert DOC_C.include_strategy is True
        assert DOC_C.include_advocacy_lever is True
        assert DOC_C.include_member_approach is True
        assert DOC_C.include_messaging_framework is False

    def test_doc_d_excludes_all_internal_content(self):
        """DOC_D has all include_* flags set to False."""
        assert DOC_D.include_strategy is False
        assert DOC_D.include_advocacy_lever is False
        assert DOC_D.include_member_approach is False
        assert DOC_D.include_messaging_framework is False


class TestAudienceAndScope:
    """Verify audience/scope properties."""

    def test_doc_a_is_internal_tribal(self):
        """DOC_A: internal audience, tribal scope."""
        assert DOC_A.is_internal is True
        assert DOC_A.is_congressional is False
        assert DOC_A.is_tribal is True
        assert DOC_A.is_regional is False

    def test_doc_b_is_congressional_tribal(self):
        """DOC_B: congressional audience, tribal scope."""
        assert DOC_B.is_internal is False
        assert DOC_B.is_congressional is True
        assert DOC_B.is_tribal is True
        assert DOC_B.is_regional is False

    def test_doc_c_is_internal_regional(self):
        """DOC_C: internal audience, regional scope."""
        assert DOC_C.is_internal is True
        assert DOC_C.is_congressional is False
        assert DOC_C.is_tribal is False
        assert DOC_C.is_regional is True

    def test_doc_d_is_congressional_regional(self):
        """DOC_D: congressional audience, regional scope."""
        assert DOC_D.is_internal is False
        assert DOC_D.is_congressional is True
        assert DOC_D.is_tribal is False
        assert DOC_D.is_regional is True


class TestNarrativeVoiceAndFraming:
    """Verify narrative voice and structural asks framing."""

    def test_internal_docs_are_assertive(self):
        """Internal docs use assertive narrative voice."""
        assert DOC_A.narrative_voice == "assertive"
        assert DOC_C.narrative_voice == "assertive"

    def test_congressional_docs_are_objective(self):
        """Congressional docs use objective narrative voice."""
        assert DOC_B.narrative_voice == "objective"
        assert DOC_D.narrative_voice == "objective"

    def test_internal_docs_use_strategic_framing(self):
        """Internal docs frame structural asks as strategic."""
        assert DOC_A.structural_asks_framing == "strategic"
        assert DOC_C.structural_asks_framing == "strategic"

    def test_congressional_docs_use_policy_framing(self):
        """Congressional docs frame structural asks as policy_recommendation."""
        assert DOC_B.structural_asks_framing == "policy_recommendation"
        assert DOC_D.structural_asks_framing == "policy_recommendation"


class TestFormatHeader:
    """Verify header template substitution."""

    def test_format_header_tribal_internal(self):
        """DOC_A header substitutes tribe_name correctly."""
        result = DOC_A.format_header(tribe_name="Muckleshoot Indian Tribe")
        assert result == "Muckleshoot Indian Tribe | Internal Strategy | CONFIDENTIAL"

    def test_format_header_tribal_congressional(self):
        """DOC_B header substitutes tribe_name correctly."""
        result = DOC_B.format_header(tribe_name="Tulalip Tribes")
        assert result == f"Tulalip Tribes | {FISCAL_YEAR_SHORT} Climate Resilience Program Priorities"

    def test_format_header_regional_internal(self):
        """DOC_C header substitutes region_name correctly."""
        result = DOC_C.format_header(region_name="Pacific Northwest")
        assert result == "Pacific Northwest | Regional Strategy | CONFIDENTIAL"

    def test_format_header_regional_congressional(self):
        """DOC_D header substitutes region_name correctly."""
        result = DOC_D.format_header(region_name="Great Plains")
        assert result == f"Great Plains | {FISCAL_YEAR_SHORT} Regional Climate Resilience Overview"

    def test_format_header_no_placeholder_leaves_template(self):
        """Calling format_header without args leaves placeholders intact."""
        result = DOC_A.format_header()
        assert "{tribe_name}" in result

    def test_format_header_both_placeholders(self):
        """Passing both tribe_name and region_name substitutes both."""
        result = DOC_A.format_header(
            tribe_name="TestTribe", region_name="TestRegion"
        )
        assert "TestTribe" in result


class TestFormatFilename:
    """Verify filename generation."""

    def test_format_filename_doc_a(self):
        """DOC_A generates correct filename with internal_strategy suffix."""
        result = DOC_A.format_filename("epa_001")
        fy = FISCAL_YEAR_SHORT.lower()
        assert result == f"epa_001_internal_strategy_{fy}.docx"

    def test_format_filename_doc_b(self):
        """DOC_B generates correct filename with congressional_overview suffix."""
        result = DOC_B.format_filename("epa_001")
        fy = FISCAL_YEAR_SHORT.lower()
        assert result == f"epa_001_congressional_overview_{fy}.docx"

    def test_format_filename_doc_c(self):
        """DOC_C generates correct filename with intertribal_strategy suffix."""
        result = DOC_C.format_filename("pnw")
        fy = FISCAL_YEAR_SHORT.lower()
        assert result == f"pnw_intertribal_strategy_{fy}.docx"

    def test_format_filename_doc_d(self):
        """DOC_D generates correct filename with regional_congressional_overview suffix."""
        result = DOC_D.format_filename("plains")
        fy = FISCAL_YEAR_SHORT.lower()
        assert result == f"plains_regional_congressional_overview_{fy}.docx"


class TestAirGapCompliance:
    """Verify no organizational attribution in any configuration value."""

    @pytest.mark.parametrize("config", [DOC_A, DOC_B, DOC_C, DOC_D],
                             ids=["DOC_A", "DOC_B", "DOC_C", "DOC_D"])
    def test_no_forbidden_strings_in_config(self, config):
        """No config field contains forbidden organizational strings."""
        # Check all string fields
        string_fields = [
            config.doc_type,
            config.audience,
            config.scope,
            config.title_template,
            config.header_template,
            config.footer_template,
            config.structural_asks_framing,
            config.narrative_voice,
            config.filename_suffix,
        ]
        for field_value in string_fields:
            for forbidden in FORBIDDEN_STRINGS:
                assert forbidden.lower() not in field_value.lower(), (
                    f"Air gap violation: '{forbidden}' found in "
                    f"config field value '{field_value}' for DOC_{config.doc_type}"
                )

    @pytest.mark.parametrize("config", [DOC_A, DOC_B, DOC_C, DOC_D],
                             ids=["DOC_A", "DOC_B", "DOC_C", "DOC_D"])
    def test_no_forbidden_strings_in_formatted_header(self, config):
        """Formatted headers with sample data contain no forbidden strings."""
        header = config.format_header(
            tribe_name="Test Tribe", region_name="Test Region"
        )
        for forbidden in FORBIDDEN_STRINGS:
            assert forbidden.lower() not in header.lower(), (
                f"Air gap violation: '{forbidden}' found in formatted "
                f"header '{header}' for DOC_{config.doc_type}"
            )

    @pytest.mark.parametrize("config", [DOC_A, DOC_B, DOC_C, DOC_D],
                             ids=["DOC_A", "DOC_B", "DOC_C", "DOC_D"])
    def test_no_forbidden_strings_in_formatted_filename(self, config):
        """Formatted filenames contain no forbidden strings."""
        filename = config.format_filename("test_slug")
        for forbidden in FORBIDDEN_STRINGS:
            assert forbidden.lower() not in filename.lower(), (
                f"Air gap violation: '{forbidden}' found in formatted "
                f"filename '{filename}' for DOC_{config.doc_type}"
            )
