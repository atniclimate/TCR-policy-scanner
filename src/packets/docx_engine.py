"""DocxEngine -- assembles complete per-Tribe advocacy packet DOCX documents.

Creates a python-docx Document with programmatic styles, delegates section
rendering to specialized renderers, and saves to the output directory.
"""

import logging
import os
import tempfile
from datetime import datetime, timezone
from pathlib import Path

from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Inches, Pt, RGBColor

from src.packets.context import TribePacketContext
from src.packets.docx_hotsheet import HotSheetRenderer
from src.packets.docx_sections import (
    render_appendix,
    render_cover_page,
    render_table_of_contents,
)
from src.packets.docx_styles import COLORS, StyleManager
from src.packets.economic import TribeEconomicSummary

logger = logging.getLogger("tcr_scanner.packets.docx_engine")


class DocxEngine:
    """Assembles and saves styled DOCX advocacy packets.

    Creates a python-docx Document with all custom styles applied via
    StyleManager, configures page layout, and saves to the output
    directory using an atomic write pattern.

    Usage::

        engine = DocxEngine(config, programs)
        doc, sm = engine.create_document()
        # ... add content via renderers ...
        path = engine.save(doc, "epa_123")
    """

    def __init__(self, config: dict, programs: dict[str, dict]) -> None:
        """Initialize the engine with config and program inventory.

        Args:
            config: Application configuration dict (with ``packets`` section).
            programs: Dict of program dicts keyed by program ID.
        """
        self.config = config
        self.programs = programs
        self.output_dir = Path(
            config.get("packets", {}).get("output_dir", "outputs/packets")
        )
        self.output_dir.mkdir(parents=True, exist_ok=True)
        logger.debug("DocxEngine initialized, output_dir=%s", self.output_dir)

    def create_document(self) -> tuple[Document, StyleManager]:
        """Create a fresh Document with all custom styles and page layout.

        Returns:
            Tuple of (Document, StyleManager) ready for content rendering.
        """
        document = Document()
        style_manager = StyleManager(document)

        # Configure page margins (1 inch all sides)
        for section in document.sections:
            section.top_margin = Inches(1)
            section.bottom_margin = Inches(1)
            section.left_margin = Inches(1)
            section.right_margin = Inches(1)

        self._setup_header_footer(document)

        logger.debug("Created new document with styles and page layout")
        return document, style_manager

    def _setup_header_footer(self, document: Document) -> None:
        """Configure document header and footer text.

        Header: "TCR Policy Scanner | Tribal Advocacy Packet" (Arial 8pt, muted)
        Footer: "CONFIDENTIAL | Generated by TCR Policy Scanner" (Arial 7pt, muted, centered)

        Args:
            document: The python-docx Document to configure.
        """
        for section in document.sections:
            # Header
            header = section.header
            header.is_linked_to_previous = False
            header_para = header.paragraphs[0] if header.paragraphs else header.add_paragraph()
            header_run = header_para.add_run(
                "TCR Policy Scanner | Tribal Advocacy Packet"
            )
            header_run.font.size = Pt(8)
            header_run.font.color.rgb = COLORS.muted
            header_run.font.name = "Arial"

            # Footer
            footer = section.footer
            footer.is_linked_to_previous = False
            footer_para = footer.paragraphs[0] if footer.paragraphs else footer.add_paragraph()
            footer_run = footer_para.add_run(
                "CONFIDENTIAL | Generated by TCR Policy Scanner"
            )
            footer_run.font.size = Pt(7)
            footer_run.font.color.rgb = COLORS.muted
            footer_run.font.name = "Arial"
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

    def save(self, document: Document, tribe_id: str) -> Path:
        """Save the document to disk using an atomic write pattern.

        Writes to a temporary file first, then atomically replaces the
        target path. This prevents partial/corrupt files on crash.

        Warning:
            Not safe for concurrent execution by multiple processes
            targeting the same tribe_id. If parallel packet generation
            is needed, use external locking or a task queue with
            single-worker concurrency per tribe_id.

        Args:
            document: The completed python-docx Document.
            tribe_id: Tribe identifier used as filename stem.

        Returns:
            Path to the saved .docx file.

        Raises:
            ValueError: If tribe_id contains path traversal sequences.
        """
        # Sanitize tribe_id to prevent path traversal
        safe_id = Path(tribe_id).name
        if not safe_id or safe_id in (".", ".."):
            raise ValueError(f"Invalid tribe_id: {tribe_id!r}")

        output_path = self.output_dir / f"{safe_id}.docx"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Atomic write: save to tmp, then replace.
        # Close handle before save to avoid Windows file-locking conflicts.
        tmp_fd = tempfile.NamedTemporaryFile(
            dir=str(self.output_dir), suffix=".docx", delete=False
        )
        tmp_name = tmp_fd.name
        tmp_fd.close()
        try:
            document.save(tmp_name)
            os.replace(tmp_name, str(output_path))
        except Exception:
            try:
                os.unlink(tmp_name)
            except OSError:
                pass
            raise

        logger.info("Saved advocacy packet: %s", output_path)
        return output_path

    def generate(
        self,
        context: TribePacketContext,
        relevant_programs: list[dict],
        economic_summary: TribeEconomicSummary,
        structural_asks: list[dict],
        omitted_programs: list[dict] | None = None,
    ) -> Path:
        """Generate a complete advocacy packet DOCX for a single Tribe.

        Assembles the full document: cover page, table of contents, Hot Sheet
        pages for each relevant program, and an appendix of omitted programs.

        Args:
            context: TribePacketContext with all Tribe data.
            relevant_programs: List of program dicts relevant to this Tribe.
            economic_summary: Aggregated economic impact calculations.
            structural_asks: List of structural ask dicts from graph schema.
            omitted_programs: Optional list of programs not included in
                Hot Sheets (rendered in appendix).

        Returns:
            Path to the saved .docx file.
        """
        document, style_manager = self.create_document()

        # 1. Cover page
        render_cover_page(document, context, style_manager)

        # 2. Table of contents
        render_table_of_contents(document, relevant_programs, context, style_manager)

        # 3. Hot Sheets for all relevant programs
        renderer = HotSheetRenderer(document, style_manager)
        renderer.render_all_hotsheets(
            context, relevant_programs, economic_summary, structural_asks
        )

        # 4. Appendix (omitted programs or "all included" note)
        document.add_page_break()
        render_appendix(
            document, omitted_programs or [], context, style_manager
        )

        # 5. Save and return path
        tribe_id = getattr(context, "tribe_id", "unknown")
        output_path = self.save(document, tribe_id)

        logger.info(
            "Generated complete packet for %s: %d Hot Sheets, %d omitted programs",
            context.tribe_name,
            len(relevant_programs),
            len(omitted_programs or []),
        )
        return output_path
