"""DocxEngine -- assembles complete per-Tribe advocacy packet DOCX documents.

Creates a python-docx Document with programmatic styles, delegates section
rendering to specialized renderers, and saves to the output directory.
"""

import logging
import os
import tempfile
from datetime import datetime, timezone
from pathlib import Path

from docx import Document
from docx.shared import Inches, Pt, RGBColor

from src.packets.docx_styles import COLORS, StyleManager

logger = logging.getLogger("tcr_scanner.packets.docx_engine")


class DocxEngine:
    """Assembles and saves styled DOCX advocacy packets.

    Creates a python-docx Document with all custom styles applied via
    StyleManager, configures page layout, and saves to the output
    directory using an atomic write pattern.

    Usage::

        engine = DocxEngine(config, programs)
        doc, sm = engine.create_document()
        # ... add content via renderers ...
        path = engine.save(doc, "epa_123")
    """

    def __init__(self, config: dict, programs: dict[str, dict]) -> None:
        """Initialize the engine with config and program inventory.

        Args:
            config: Application configuration dict (with ``packets`` section).
            programs: Dict of program dicts keyed by program ID.
        """
        self.config = config
        self.programs = programs
        self.output_dir = Path(
            config.get("packets", {}).get("output_dir", "outputs/packets")
        )
        self.output_dir.mkdir(parents=True, exist_ok=True)
        logger.debug("DocxEngine initialized, output_dir=%s", self.output_dir)

    def create_document(self) -> tuple[Document, StyleManager]:
        """Create a fresh Document with all custom styles and page layout.

        Returns:
            Tuple of (Document, StyleManager) ready for content rendering.
        """
        document = Document()
        style_manager = StyleManager(document)

        # Configure page margins (1 inch all sides)
        for section in document.sections:
            section.top_margin = Inches(1)
            section.bottom_margin = Inches(1)
            section.left_margin = Inches(1)
            section.right_margin = Inches(1)

        self._setup_header_footer(document)

        logger.debug("Created new document with styles and page layout")
        return document, style_manager

    def _setup_header_footer(self, document: Document) -> None:
        """Configure document header and footer text.

        Header: "TCR Policy Scanner | Tribal Advocacy Packet" (Arial 8pt, muted)
        Footer: "CONFIDENTIAL | Generated by TCR Policy Scanner" (Arial 7pt, muted, centered)

        Args:
            document: The python-docx Document to configure.
        """
        for section in document.sections:
            # Header
            header = section.header
            header.is_linked_to_previous = False
            header_para = header.paragraphs[0] if header.paragraphs else header.add_paragraph()
            header_run = header_para.add_run(
                "TCR Policy Scanner | Tribal Advocacy Packet"
            )
            header_run.font.size = Pt(8)
            header_run.font.color.rgb = COLORS.muted
            header_run.font.name = "Arial"

            # Footer
            footer = section.footer
            footer.is_linked_to_previous = False
            footer_para = footer.paragraphs[0] if footer.paragraphs else footer.add_paragraph()
            footer_run = footer_para.add_run(
                "CONFIDENTIAL | Generated by TCR Policy Scanner"
            )
            footer_run.font.size = Pt(7)
            footer_run.font.color.rgb = COLORS.muted
            footer_run.font.name = "Arial"
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

    def save(self, document: Document, tribe_id: str) -> Path:
        """Save the document to disk using an atomic write pattern.

        Writes to a temporary file first, then atomically replaces the
        target path. This prevents partial/corrupt files on crash.

        Args:
            document: The completed python-docx Document.
            tribe_id: Tribe identifier used as filename stem.

        Returns:
            Path to the saved .docx file.
        """
        output_path = self.output_dir / f"{tribe_id}.docx"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Atomic write: save to tmp, then replace
        tmp_fd = tempfile.NamedTemporaryFile(
            dir=str(self.output_dir), suffix=".docx", delete=False
        )
        try:
            document.save(tmp_fd.name)
            tmp_fd.close()
            os.replace(tmp_fd.name, str(output_path))
        except Exception:
            tmp_fd.close()
            # Clean up tmp file on failure
            try:
                os.unlink(tmp_fd.name)
            except OSError:
                pass
            raise

        logger.info("Saved advocacy packet: %s", output_path)
        return output_path

    def generate(self, context, relevant_programs, economic_summary, structural_asks) -> Path:
        """Generate a complete advocacy packet DOCX for a single Tribe.

        .. note::
            Stub implementation. Plan 07-04 will complete this with
            section assembly (cover page, program matrix, hazard profile,
            economic impact, congressional briefing, key asks).

        Args:
            context: TribePacketContext with all Tribe data.
            relevant_programs: Dict of programs relevant to this Tribe.
            economic_summary: Economic impact calculations.
            structural_asks: Prioritized structural asks for advocacy.

        Returns:
            Path to the saved .docx file.
        """
        # TODO: Plan 07-04 will complete this with section assembly
        document, style_manager = self.create_document()

        # Placeholder: add Tribe name as title
        document.add_paragraph(
            getattr(context, "tribe_name", "Tribal Advocacy Packet"),
            style="HS Title",
        )

        tribe_id = getattr(context, "tribe_id", "unknown")
        return self.save(document, tribe_id)
